# C++类的六大函数

### 总览

- 拷贝构造 和 移动构造 都是用已有对象 构造新的对象；
  - 如果已有对象**仍需引用或利用**，需要自定义**拷贝**构造函数（深拷贝）；
  - 如果已有对象**无需引用或利用**，需要自定义**移动**构造函数（浅拷贝）；
- 拷贝赋值 和 移动赋值 都是将已有对象赋值另一个已有对象；
  - 如果已有对象**仍需引用或利用**，需要自定义**拷贝**赋值函数（深拷贝）；
  - 如果已有对象**无需引用或利用**，需要自定义**移动**赋值函数（浅拷贝）

```c++
class T{
    T();                	//默认的构造函数
    T(SomeType);        	//普通的构造函数
    T(const T&);        	//拷贝构造函数
    T(T&&);             	//移动构造函数
    T& operator=(const T&); //拷贝赋值函数
    T& operator=(T&&);      //移动赋值函数
    ~T();                   //析构函数
}
```

一个空类，编译器默认添加以下函数：

- 默认构造函数和拷贝构造函数
- 析构函数
- 赋值函数（赋值运算符）
- 取值函数

### 构造函数

**构造函数可以被重载，可以多个，可以带参数**

**构造函数调用顺序**

1. 调用父类构造函数； 
2. 调用类成员的构造函数（成员函数中有类对象）； 
3. 调用构造函数体

#### 初始化列表

`std::initializer_list`是C++标准库中的一个类型，使用这种类型作为参数的构造函数就称作“初始化列表构造函数”。

使用初始化列表对对象进行初始化的好处是，**对对象的数目没有限制，可以传递变长的参数**。

```c++
class T{
public:
    char * p;
    T(initializer_list<char> list){
        p=new char[list.size()];
        for (int i=0;i!=list.size();i++){
            p[i]=list.begin()[i];}
    }
    ~T(){delete [] p;}
}
T obj1{'a','b','c','d','e'};//使用初始化列表显式调用构造函数
T obj2={'a','b','c'};/*注意，由于构造函数没有使用explicit声明，因此，支持隐式转换*/
```

#### 异常

当构造函数抛出异常的时候，很可能类对象仅仅完成了部分构造，未经任何处理的情况下，很可能不满足异常安全。如果此时直接进入异常处理程序，程序的内存状态是不确定的，异常处理完成后，也不知道应该将程序返回到何种状态。因此必须清理已经完成的部分构造。

### 析构函数

**析构函数只有一个，不能被重载，不带参数**

**析构函数的调用顺序**

1. 派生类本身的析构函数
2. 对象成员析构函数
3. 基类析构函数

在离开作用域或者被`delete`的时候会调用构造函数；

#### 异常

一般来说，析构函数中不允许抛出异常。

### 拷贝构造函数

#### 前提知识点

1. 深拷贝与浅拷贝

#### 基本概念

用一个**已有**对象去**初始化**一个**新的**对象。

**默认**拷贝构造函数工作方式**浅拷贝**，当对象中用到了需要手动释放的对象或者内存，则会出现问题，需要重载拷贝构造函数，实现深拷贝。

**拷贝构造函数被调用**：

1. 一个对象以值传递的方式传入函数体
2. 一个对象以值传递的方式从函数返回
3. 一个对象需要通过另外一个对象进行初始化。

```c++
A(const A& a) : x(a.x)
{
cout << "Copy Constructor" << endl;
}
```

### 移动构造函数



### 拷贝赋值函数



### 移动赋值函数



### 举例验证

```c++
#include <iostream>
using namespace std;

class A {
public:
    int x;
    A(int x) : x(x){
        cout << "Constructor" << endl;
    }
    A(A& a) : x(a.x){
        cout << "Copy Constructor" << endl;
    }
    A& operator=(A& a){
        x = a.x;
        cout << "Copy Assignment operator" << endl;
        return *this;
    }
    A(A&& a) : x(a.x){
        cout << "Move Constructor" << endl;
    }
    A& operator=(A&& a){
        x = a.x;
        cout << "Move Assignment operator" << endl;
        return *this;
    }
};
A GetA(){
    return A(1);
}
A&& MoveA(A& a){
    return std::move(a);
}
int main(){
    A a(1);     //构造函数，无需解释
    A b = a;    //拷贝构造，用已有创建新的
    A c(a);     //拷贝构造，用已有创建新的
    b = a;      //拷贝赋值，用已有的a给b更新值
    A d = A(1); //移动构造，用A(1)初始化d，临时对象A(1)是右值，故移动构造初始化d
    A e = std::move(a); //移动构造,左值 a 转为了右值
    A f = GetA();       //构造A(1),再移动构造一个临时对象，用临时对象移动构造f
    A&& g = MoveA(f);   //不创建对象，也不更新对象，只是将MoveA()返回值绑定到右值引用g
    d = A(1);           //移动赋值
}
```

参考链接的输出：

```c++
-------------------------1-------------------------
Constructor
-------------------------2-------------------------
Copy Constructor
-------------------------3-------------------------
Copy Constructor
-------------------------4-------------------------
Copy Assignment operator
-------------------------5-------------------------
Constructor
Move Constructor
-------------------------6-------------------------
Move Constructor
-------------------------7-------------------------
Constructor
Move Constructor
Move Constructor
-------------------------8-------------------------
-------------------------9-------------------------
Constructor
Move Assignment operator
```

实际运行的输出：

```
-------------------------1-------------------------
Constructor
-------------------------2-------------------------
Copy Constructor
-------------------------3-------------------------
Copy Constructor
-------------------------4-------------------------
Copy Assignment operator
-------------------------5-------------------------
Constructor
-------------------------6-------------------------
Move Constructor
-------------------------7-------------------------
Constructor
-------------------------8-------------------------
-------------------------9-------------------------
Constructor
Move Assignment operator
```



### 参考链接

1. [C++类的六大函数--构造、析构、拷贝构造、移动构造、拷贝赋值、移动赋值](https://www.cnblogs.com/lincz/p/10768607.html)
2. [C++构造、析构、拷贝构造、拷贝赋值、移动构造、移动赋值（一） (fengyuanblog.github.io)](https://fengyuanblog.github.io/2017/06/20/C++构造-析构-拷贝构造-拷贝赋值-移动构造-移动赋值-一/)
3. [C++构造、析构、拷贝构造、拷贝赋值、移动构造、移动赋值（二） (fengyuanblog.github.io)](https://fengyuanblog.github.io/2017/06/20/C++构造-析构-拷贝构造-拷贝赋值-移动构造-移动赋值-二/)
4. [C++构造、析构、拷贝构造、拷贝赋值、移动构造、移动赋值（三） (fengyuanblog.github.io)](https://fengyuanblog.github.io/2017/06/20/C++构造-析构-拷贝构造-拷贝赋值-移动构造-移动赋值-三/)
5. [拷贝构造函数和移动构造函数](https://www.cnblogs.com/hunter-w/p/13884186.html)

