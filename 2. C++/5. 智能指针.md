# 智能指针
## 目录 or TODO
- [x] 1.背景
- [x] 2.两个指针指向同一个对象
- [x] 3.auto_ptr
- [x] 4.unique_ptr
- [x] 5.shared_ptr
- [x] 6.weak_ptr
- [x] 7.参考资料
## 正文

### 1. 背景

#### 1.1. 裸指针

裸指针的不足：

1. 手动申请的内存忘记释放，造成内存泄漏；
2. 多个指针指向同一资源，当其中一个指针将资源释放后，后续指针成为悬挂指针；
3. 当程序执行出错提前退出，裸指针指向的资源未释放，同样会造成内存泄漏；

**智能指针**对裸指针进行了面向对象的封装。智能指针的行为类似常规指针，重要的区别是它**负责自动释放所指向的对象**，在构造函数中初始化资源地址，在析构函数中释放资源。

`shared_ptr` `unique_ptr` `weak_ptr`三者都定义在memory头文件中，和`vector`一样都是模板。

**所有的智能指针类都有一个 explicit 构造函数**，以指针作为参数，**不支持隐式转换**。

```c++
shared_ptr<double> pd; 
double *p_reg = new double;
pd = p_reg;                               // not allowed (implicit conversion)
pd = shared_ptr<double>(p_reg);           // allowed (explicit conversion)
shared_ptr<double> pshared = p_reg;       // not allowed (implicit conversion)
shared_ptr<double> pshared(p_reg);        // allowed (explicit conversion)

//pvac 过期时，程序将把 delete 运算符用于非堆内存，这是错误的。
string vacation("I wandered lonely as a cloud.");
shared_ptr<string> pvac(&vacation);   // No
```

### 2. 两个指针指向同一个对象

当两个普通指针指向同一个对象时，前一个指针释放对象的话会造成后一个指针指向无效对象。解决办法如下：

- 定义赋值运算符，使之执行深复制。使另一个指针指向该对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。
- 建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。**赋值操作转让所有权**。这就是用于`auto_ptr`和`unique_ptr`的策略。
- 跟踪引用特定对象的智能指针数，这称为引用计数。例如，赋值时，计数将**加1**，而指针过期时，计数将**减1**。当减为0时才调用`delete`。这是`shared_ptr`采用的策略。

### 3. auto_ptr

采用的是建立**所有权**的方式。

```C++
#include <memory>
int main() {
  auto_ptr<string> films[5] ={
  ...
  auto_ptr<string> (new string("Chicken Runs")),
  ...
 };
 auto_ptr<string> pwin;
 // films[2]将所有权从films[2]转让给pwin，变成了空指针
 pwin = films[2]; 
    
 for(int i = 0; i < 5; ++i)
  	cout << *films[i] << endl; 	// 访问 films[2]时，程序会奔溃
}
```

不能在容器中使用 `auto_ptr`，当容器发生拷贝时，原容器中 `auto_ptr` 持有的资源会置 `nullptr`

部分源码

```c++
template<class _Ty>
class auto_ptr{ 
public:
    typedef _Ty element_type;
    explicit auto_ptr(_Ty * _Ptr=nullptr) noexcept
        : _Myptr(_Ptr)//初始化列表
        { //构造函数}
    auto_ptr(auto_ptr& _Right) noexcept
        : _Myptr(_Right.release())
        { //拷贝构造函数，会调用release()函数}
    _Ty * release() noexcept
    {
        /*使用拷贝构造时，最后一个auto_ptr持有资源，其余被置为nullptr*/ 
        _Ty * _Tmp = _Myptr;
        _Myptr = nullptr;
        return (_Tmp);
    }
private:
 _Ty * _Myptr;//指向资源 
};
```

在 `auto_ptr` 的拷贝构造函数时，在初始化列表中调用了 `release()` 函数，相当于源指针把资源交给了新指针。

### 4. unique_ptr

建立**所有权**的方式，但是会在编译阶段检查指针是否为空指针，所以比`auto_ptr`更优。

**独占所有权**，没有拷贝函数，没有赋值函数，有移动构造函数和移动赋值函数。

在访问资源前，使用成员函数 `get()` 进行判空操作。

通常不单独使用（没有实际用处），只能和 `shared_ptr` 类型指针搭配使用。借助 `weak_ptr` 类型指针可以获取 `shared_ptr` 指针的一些状态信息：比如有多少指向相同的 `shared_ptr` 指针、`shared_ptr` 指针指向的堆内存是否已经被释放等等。

**`weak_ptr` 类型指针并不会影响所指堆内存空间的引用计数**。

没有重载`*` 和 `->`运算符，所以**无法修改其指向的对象**；

| 成员方法      | 功 能                                                        |
| ------------- | ------------------------------------------------------------ |
| `use_count()` | 查看指向和当前 `weak_ptr` 指针相同的 `shared_ptr` 指针的数量。 |
| `expired()`   | 判断当前 `weak_ptr` 指针为否过期（指针为空，或者指向的堆内存已经被释放）。 |
| `lock()`      | 如果当前 `weak_ptr` 已经过期，则该函数会返回一个空的 `shared_ptr` 指针；反之，该函数返回一个和当前 `weak_ptr` 指向相同的 `shared_ptr` 指针。 |

部分源码

```c++
template<class _Ty,class _Dx>
class unique_ptr: public _Unique_ptr_base<_Ty, _Dx>{ 
    public:
    typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
    typedef typename _Mybase::pointer pointer;
    typedef _Ty element_type;
    typedef _Dx deleter_type;

    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mybase(_Right.release(),
                  _STD forward<_Dx>(_Right.get_deleter()))
        {// 右值引用的拷贝构造函数}

    unique_ptr& operator=(unique_ptr&& _Right) noexcept{ 
        //提供了右值引用的operator=赋值构造函数
        if (this != _STD addressof(_Right)){ 
            reset(_Right.release());
            this->get_deleter() = _STD forward<_Dx>
                (_Right.get_deleter());
        }
        return (*this);
    }
    /*删除了unique_ptr的拷贝构造和赋值函数，拒绝浅拷贝*/
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
 };
```

禁止了拷贝和赋值操作，杜绝浅拷贝，但是增加了移动操作，可以把`unique_ptr`作为函数返回值。

### 5. shared_ptr

#### 5.1. 基本操作

强智能指针，采用的是**引用计数机制**，用计数器还是其他数据结构记录共享数，取决于标准库的实现，常用于**管理对象的生命周期。**

```c++
#include <memory>
shared_ptr<string> p1;
// 判空操作
if (p1 && p1->empty())
    *p1 = "test";
p1.get()；	// 返回p1中保存的指针
swap(p, q);	 // 交换p q中的指针
p.swap(q)；	// 交换p q中的指针

p.use_count(); // 返回与p共享对象的智能指针数
p.unique(); // 判断 use_count 是否为1
```

#### 5.2. `make_shared( )`

**最安全的分配和使用动态内存的方法**是调用一个名为`make_shared`的标准库函数。同样定义在头文件memory中。

```c++
shared_ptr<int> p3 =	make_shared<int>(42);
//p4指向一个值为"9999999999"的 string
shared_ptr<string> p4 = make_shared<string>(10, 9);
shared_ptr<int> p5 = make_shared<int>（）; //p5指向一个只初始化为0的int
auto p6 = make_shared<string>();	// 通常用 auto 接收
```

`make_shared()`函数的参数，必须与对象的某个构造函数的参数相匹配；

#### 5.3. 拷贝和赋值

```c++
shared_ptr<T> p(q);	// 拷贝构造，会增加q的引用计数
p = q; 		// p的引用计数减少，q的引用计数增加，若p的引用计数减少到0，则会释放指向的对象；

shared_ptr<Foo> factory(T arg){
    ...
	return make shared<Foo>(arg)
}
void use factory(T arg){
	shared_ptr<Foo> p= factory(arg);
	...
}	//p离开了作用城，它指向的内存会被自动释放掉
```

如果在函数结束前有`return p`，**返回的是`p`的拷贝，所以引用计数会增加**。

### 6. weak_ptr

弱智能指针，其对资源的引用**不会引起资源的引用计数的变化**，通常作为**观察者**，用于判断资源是否存在，并根据不同情况做出相应的操作。

### 7. 参考资料

1. [C++ 智能指针详解](https://www.cnblogs.com/greatverve/p/smart-ptr.html)
2. [C++智能指针简单剖析](https://www.cnblogs.com/lanxuezaipiao/p/4132096.html)
3. [C++11 shared_ptr智能指针](http://c.biancheng.net/view/7898.html)
4. [C++11 weak_ptr智能指针](http://c.biancheng.net/view/7918.html)
5. [C++ STL 四种智能指针_Dablelv的博客专栏](https://blog.csdn.net/K346K346/article/details/81478223)
6. [浅析 C++智能指针和 enable_shared_from_this 机制](https://mp.weixin.qq.com/s/a7Nl2jnbOtkfzEAK1TxVyA)

