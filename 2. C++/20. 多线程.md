# C++多线程

## 目录 or TODO

## 正文

### thread类

详细信息

C++11 中提供的线程类叫做 `std::thread`，以下是四个构造函数

```c++
thread() noexcept;	// 一
thread( thread&& other ) noexcept;			// 二
template< class Function, class... Args >
explicit thread( Function&& f, Args&&... args ); // 三
thread( const thread& ) = delete;			//  四
```

*   任务函数 `f` 的可选类型有很多，具体如下：
    
    *   `普通函数`，`类成员函数`，`匿名函数`，`仿函数`（这些都是可调用对象类型）
    *   可以是可调用对象包装器类型，也可以是使用绑定器绑定之后得到的类型（仿函数）

*   构造函数④：使用 `=delete` 显式删除拷贝构造，不允许线程对象之间的拷贝

#### get_id()

每个被创建出的线程实例都对应一个**唯一**的线程 ID，可以通过 `get_id()`函数获得，函数原型如下：

```c++
std::thread::id get_id() const noexcept;

// 使用方法
thread t1(func1);
t.get_id();
```

*   任务函数 `func()` 一般返回值指定为 `void`，因为子线程在调用这个函数的时候不会处理其返回值

*   当前线程的 ID 可以通过 `this_thread::get_id()`获得



**默认情况下，主线程销毁时会将与其关联的两个子线程也一并销毁**，但是这时有可能子线程中的任务还没有执行完毕，最后也就得不到我们想要的结果了。

Thread库提供了两种线程资源回收的方式

1. `加入式（join()）`
2. `分离式（detach()）`

#### join()

在某个线程中通过子线程对象调用 `join()` 函数，**调用这个函数的线程被阻塞**，但是子线程中的任务函数会继续执行，当任务执行完毕之后 `join()` 会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。

```c++
thread t(func, 520, "i love you");
thread t1(func1);

t.join();
t1.join();
```

#### detach()

主线程和子线程分离，**不会阻塞主线程**，子线程执行结束后会**自动释放**占用的系统资源。**主线程在子线程执行结束前结束，也会导致子线程的销毁。**

函数原型

```c++
void detach();
```

线程分离函数没有参数也没有返回值，只需要在线程成功之后，通过线程对象调用该函数即可，继续将上面的测试程序修改一下：

```c++
thread t(func, 520, "i love you");
thread t1(func1);

t.detach();
t1.detach();

// 防止子线程没有执行完
this_thread::sleep_for(chrono::seconds(5));
```

> 注意事项：子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过 join () 阻塞主线程等待子线程中的任务执行完毕，或者调用 get_id () 获取子线程的线程 ID。有利就有弊，鱼和熊掌不可兼得，建议使用 join ()。
>

#### joinable()

`joinable()` 函数用于判断主线程和子线程是否处理关联（连接）状态。

```c++
bool joinable() const noexcept;
```

*   创建子线程对象而**没有指定任务函数**，那么子线程不会启动，**父子线程无连接**；
*   创建子线程对象**同时指定任务函数，**子线程启动并执行任务，**父子线程自动连接；**
*   `detach()`之后，父子线程断开连接；
*   调用了join()函数后，子线程任务执行结束后响应的资源被销毁，父子之间连接会断开。

#### operator=

`线程中的资源是不能被复制的`，因此通过 `=` 操作符进行赋值操作最终并不会得到两个完全相同的对象。

```c++
thread& operator= (thread&& other) noexcept;

thread& operator= (const other&) = delete;
```

通过以上 `=` 操作符的重载声明可以得知：

*   如果 `other` 是一个右值，会进行资源所有权的转移
*   如果 `other` 不是右值，禁止拷贝，该函数被显示删除（`=delete`），不可用

#### 获取当前CPU核心数

`thread` 线程类还提供了一个静态方法，用于获取当前计算机的 CPU 核心数，根据这个结果在程序中创建出数量相等的线程，`每个线程独自占有一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的`。

```c++
static unsigned hardware_concurrency() noexcept;

// 使用
int num = thread::hardware_concurrenc();
```

### 让任务只执行一次

详细信息

#### 函数原型

使用头文件 <mutex> 中的 `std::call_once()`，确保函数在多线程环境下只被执行一次

```c++
// 函数原型
template< class Callable, class... Args >
void call_once( std::once_flag& flag, Callable&& f, Args&&... args );
```

#### 使用方法

```c++
once_flag g_flag;
void do_once(int a, string b){...}
void do_something(int age, string name){
    call_once(g_flag, do_once, 19, "luffy");
    cout << "do_something() function num = " << num++ << endl;
}

thread t1(do_something, 20, "ace");
thread t2(do_something, 20, "sabo");
thread t3(do_something, 19, "luffy");
```

### 线程同步——互斥锁

