# 智能指针

### 背景

C++没有自动内存回收机制，所以每次申请的内存（堆）需要手动回收，容易造成内存泄漏。另外还有可能提前回收之后会使用的内存，产生引用非法内存的指针。为了更加容易（更加安全）的使用动态内存，引入了**智能指针**的概念。智能指针的行为类似常规指针，重要的区别是它**负责自动释放所指向的对象**。

`shared_ptr` `unique_ptr` `weak_ptr`三者都定义在memory头文件中，和`vector`一样都是模板。

**所有的智能指针类都有一个 explicit 构造函数**，以指针作为参数，**不可以复制构造和隐式转换**

```c++
shared_ptr<double> pd; 
double *p_reg = new double;
pd = p_reg;                               // not allowed (implicit conversion)
pd = shared_ptr<double>(p_reg);           // allowed (explicit conversion)
shared_ptr<double> pshared = p_reg;       // not allowed (implicit conversion)
shared_ptr<double> pshared(p_reg);        // allowed (explicit conversion)

//pvac 过期时，程序将把 delete 运算符用于非堆内存，这是错误的。
string vacation("I wandered lonely as a cloud.");
shared_ptr<string> pvac(&vacation);   // No
```

### 两个指针指向同一个对象

当两个普通指针指向同一个对象时，前一个指针释放对象的话会造成后一个指针指向无效对象。解决办法如下：

- 定义赋值运算符，使之执行深复制。使另一个指针指向该对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。
- 建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。**赋值操作转让所有权**。这就是用于`auto_ptr`和`unique_ptr`的策略。
- 跟踪引用特定对象的智能指针数，这称为引用计数。例如，赋值时，计数将**加1**，而指针过期时，计数将**减1**。当减为0时才调用`delete`。这是`shared_ptr`采用的策略。

### auto_ptr

采用的是建立所有权的方式。

```C++
#include <memory>
int main() {
  auto_ptr<string> films[5] ={
  ...
  auto_ptr<string> (new string("Chicken Runs")),
  ...
 };
 auto_ptr<string> pwin;
 // films[2]将所有权从films[2]转让给pwin，变成了空指针
 pwin = films[2]; 
    
 for(int i = 0; i < 5; ++i)
  	cout << *films[i] << endl; 	// 访问 films[2]时，程序会奔溃
}
```



### shared_ptr

#### 基本操作

采用的是**引用计数机制**，用计数器还是其他数据结构记录共享数，取决于标准库的实现

```c++
#include <memory>
shared_ptr<string> p1;
// 判空操作
if (p1 && p1->empty())
    *p1 = "test";
p1.get()；	// 返回p1中保存的指针
swap(p, q);	 // 交换p q中的指针
p.swap(q)；	// 交换p q中的指针

p.use_count(); // 返回与p共享对象的智能指针数
p.unique(); // 判断 use_count 是否为1
```

#### `make_shared( )`

**最安全的分配和使用动态内存的方法**是调用一个名为`make_shared`的标准库函数。同样定义在头文件memory中。

```c++
shared_ptr<int> p3 =	make_shared<int>(42);
//p4指向一个值为"9999999999"的 string
shared_ptr<string> p4 = make_shared<string>(10, 9);
shared_ptr<int> p5 = make_shared<int>（）; //p5指向一个只初始化为0的int
auto p6 = make_shared<string>();	// 通常用 auto 接收
```

`make_shared()`函数的参数，必须与对象的某个构造函数的参数相匹配；

#### 拷贝和赋值

```c++
shared_ptr<T> p(q);	// 拷贝构造，会增加q的引用计数
p = q; 		// p的引用计数减少，q的引用计数增加，若p的引用计数减少到0，则会释放指向的对象；

shared_ptr<Foo> factory(T arg){
    ...
	return make shared<Foo>(arg)
}
void use factory(T arg){
	shared_ptr<Foo> p= factory(arg);
	...
}	//p离开了作用城，它指向的内存会被自动释放掉
```

如果在函数结束前有`return p`，**返回的是`p`的拷贝，所以引用计数会增加**。



### unique_ptr

`unique_ptr`采用的也是建立所有权的方式，但是会在编译阶段检查指针是否为空指针，所以比`auto_ptr`。

**独占所有权**，没有拷贝构造函数，有移动构造函数。

在访问资源前，使用成员函数 `get()` 进行判空操作。

通常不单独使用（没有实际用处），只能和 `hared_ptr` 类型指针搭配使用。借助 `weak_ptr` 类型指针可以获取 `shared_ptr` 指针的一些状态信息：比如有多少指向相同的 `shared_ptr` 指针、`shared_ptr` 指针指向的堆内存是否已经被释放等等。

**`weak_ptr` 类型指针并不会影响所指堆内存空间的引用计数**。

没有重载`*` 和 `->`运算符，所以**无法修改其指向的对象**；

| 成员方法      | 功 能                                                        |
| ------------- | ------------------------------------------------------------ |
| `use_count()` | 查看指向和当前 `weak_ptr` 指针相同的 `shared_ptr` 指针的数量。 |
| `expired()`   | 判断当前 `weak_ptr` 指针为否过期（指针为空，或者指向的堆内存已经被释放）。 |
| `lock()`      | 如果当前 `weak_ptr` 已经过期，则该函数会返回一个空的 `shared_ptr` 指针；反之，该函数返回一个和当前 `weak_ptr` 指向相同的 `shared_ptr` 指针。 |

### 参考资料

1. [C++ 智能指针详解](https://www.cnblogs.com/greatverve/p/smart-ptr.html)
2. [C++智能指针简单剖析](https://www.cnblogs.com/lanxuezaipiao/p/4132096.html)
3. [C++11 shared_ptr智能指针](http://c.biancheng.net/view/7898.html)
4. [C++11 weak_ptr智能指针](http://c.biancheng.net/view/7918.html)
5. [C++ STL 四种智能指针_Dablelv的博客专栏-C](https://blog.csdn.net/K346K346/article/details/81478223)

