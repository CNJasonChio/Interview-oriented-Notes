# 封装、继承、多态
## 目录 or TODO
- [ ] 1.封装
- [ ] 2.继承
- [ ] 3.多态
- [ ] 4.虚函数、纯虚函数
- [ ] 5.抽象类
- [ ] 6.虚基类
- [ ] 7.参考资料
## 封装、继承、多态

### 1. 封装



### 2. 继承

|           | 访问控制                                                     | 访问权限                                                     |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| public    | 基类的 public 和 protected 成员访问属性在派生类中保持不变，private 成员不可直接访问。 | 派生类中的成员函数可以访问基类中的 public 和 protected 成员，不能直接访问基类的 private 成员。派生类的对象只能访问 public 成员。 |
| protected | 基类的 public 和 protected 成员都以 protected 身份出现在派生类中，private 成员不可直接访问。 | 派生类的成员函数可以直接访问基类中的 public 和 protected 成员，不能直接访问 private 成员。派生类的对象不能直接访问从基类继承的任何成员。 |
| private   | 基类的 public 和 protected 成员都以 private 身份出现在派生类中，private 成员不可直接访问。 | 派生类的成员函数可以直接访问基类中的 public 和 protected 成员，不能直接访问 private 成员。派生类的对象不能直接访问从基类继承的任何成员。 |



#### 2.1. 派生类的构造函数和析构函数

**1.**如果基类中无构造函数，那么对于派生类来说，不管派生类是何种构造函数，编译器都会先调用的执行基类的缺省构造函数，然后再执行派生类的构造函数。

**2**.如果基类有一个无缺省参数的构造函数，那么对于派生类一旦没有构造函数，那么就不会自动的先构造基类的构造函数，这是不允许的。

**3**.如果基类中有缺省参数的构造函数B()，那么派生类中没有构造函数也是允许的，编译器会自动调用。

### 3. 多态

在继承层次中，父类的指针可以具有多种形态——当其指向某个子类对象时，通过它能够调用到子类的函数，而非父类的函数。

#### 3.1. 静态多态

在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，**静态多态是由模板和重载实现的**，在宏多态中，是通过定义变量，编译时直接把变量替换，实现宏多态。

#### 3.2. 动态多态

在程序运行时才能确定函数和实现的链接。

有相同功能的一些类，希望能够抽象出一些共有的方法，将其在基类中声明为接口，然后子类继承基类并去重写这些接口，然后通过基类的指针调用不同子类之间相同的函数，实现接口重用。**动态多态的实现是基于虚函数表的机制。**

#### 3.3. 虚函数表

**含有**虚函数**或者父类含有**虚函数的类有一张虚函数表，存放在数据段中，**可以理解为类的静态成员**，表中每一项是一个虚函数的地址。虚函数表的**指针**始终位于**每个对象的内存的最前方**。这是**为了保证**多层继承或多重继承的情况下能以**最高效率**取到虚函数表。**虚指针在构造函数中初始化。**

```c++
Base b(1000);
int* vptrAddr = (int *)(&b);  // 对象 b 的虚表指针的地址
```

表中存放的是一系列虚函数的地址，按照类中虚函数声明的顺序一致。

```c++
typedef void(*Fun)(void);
Fun vfunc = (Fun)*( (int *)*(int*)(&b));
cout << "第一个虚函数的地址是：" << (int *)*(int*)(&b) << endl;
cout << "通过地址，调用虚函数Base::print()：";
vfunc();
```

- 虚函数表指针的值： `*(int*)(&b)`，也就是虚函数表的地址
- 把虚函数表的地址强制转换成 `int*` : `(int*)*(int*)(&b)`
- 再把它转化成我们Fun指针类型 ： `(Fun)*(int*)*(int*)(&b)`

所以可以通过 `vfunc();`进行调用，同理第二个虚函数的地址是 `(int*)*(int*)((&b)+1) `

### 4. 虚函数、纯虚函数

#### 4.1. 虚函数

C++的虚函数主要作用是“**运行时多态**”，父类中提供虚函数的实现，**为子类提供默认的函数实现**。

**子类可以重写父类的虚函数实现子类的特殊化。**

虚函数是非静态的、非内联的成员函数，而不能是友元函数，但虚函数可以在另一个类中被声明为友元函数。

##### 4.1.1. 什么函数不能是虚函数：

- 友元函数，这玩意儿压根就不是成员函数，更不能为虚。
- 全局函数
- 静态成员函数，这没有`this`指针做参数。
- 各种构造函数以及操作符重载一般不建议为虚函数，这也是编译期要求的；
- 构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。

虚函数能不能是`inline`呢？不能。

#### 4.2. 纯虚函数

`virtual void Print( ) = 0 ;`

**纯虚函数的标志是：在其声明后有一个特殊的语法 =0**

### 5. 抽象类

定义：带有纯虚函数的类成为抽象类；

注意事项：

1. 不能定义对象，可以把该类的构造函数设置为`protected`；
2. 如果派生类不实现抽象类的纯虚函数，那该派生类也会成为抽象类；

若一个类的构造函数声明为`private`，则该类和该类的派生类都不能创建对象；若构造函数声明为`protected`，则该类不能创建对象，但它的派生类是可以创建对象的。

### 6. 虚基类



### 7. 参考资料

1. [C++ 纯虚函数和抽象类](https://www.cnblogs.com/wkfvawl/p/10802625.html)；
2. [C++ - 虚基类、虚函数与纯虚函数](https://developer.aliyun.com/article/441299)
3. [C++三大特性 封装 继承 多态](https://www.cnblogs.com/qianqiannian/p/6037520.html)
4. [C++干货系列——谈谈C++中的动与静](https://zhuanlan.zhihu.com/p/268941222)
5. [C++ 派生类构造函数和析构函数](https://www.cnblogs.com/wkfvawl/p/10738409.html)
6. [C++编译期多态与运行期多态](https://www.cnblogs.com/QG-whz/p/5132745.html)

