# 一些关键字梳理

### explicit

#### 介绍

- 只能用于修饰只有一个参数的类构造函数

- explicit 修饰构造函数时，可以**防止隐式转换和复制初始化**

- explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

  ```c++
  struct A{
  	A(int) { }
  	operator bool() const { return true; }
  };
  struct B{
  	explicit B(int) {}
  	explicit operator bool() const { return true; }
  };
  void doA(A a) {}
  void doB(B b) {}
  int main(){
  	A a1(1);		// OK：直接初始化
  	A a2 = 1;		// OK：复制初始化
  	A a3{ 1 };		// OK：直接列表初始化
  	A a4 = { 1 };		// OK：复制列表初始化
  	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
  	doA(1);			// OK：允许从 int 到 A 的隐式转换
  	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a6(a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化
      
  	B b1(1);		// OK：直接初始化
  	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
  	B b3{ 1 };		// OK：直接列表初始化
  	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
  	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
  	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
  	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
  	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
  	return 0;
  }
  ```

#### 参考链接

1. [C++ explicit关键字详解](https://blog.csdn.net/guoyunfei123/article/details/89003369)

### union

#### 基础

##### 定义

一种特殊的类，一个union可以有多个数据成员

```c++
union Token{
   char cval;
   int ival;
   double dval;
};
```

##### 互斥赋值

**在任意时刻，联合中只能有一个数据成员可以有值**。当给联合中某个成员赋值之后，该联合中的其它成员就变成未定义状态了。

##### 字节数

**union的字节数至少能容纳其最大的数据成员**。因为token中长度最大的变量是double类型，所以token的长度是8个字节。

##### 访问权限

默认为public，可以指定为protected和private

##### 指定成员长度

```c++
union U {
    unsigned short int aa;
    struct {
        unsigned int bb : 7;//(bit 0-6)
        unsigned int cc : 6;//(bit 7-12)
        unsigned int dd : 3;//(bit 13-15)
    };
} u;

u.aa = 0xE07F;
```

##### 类当union的成员

```c++
class CA{
     int m_a;
};
union Test{
     CA a;
     double d;
};
```

上述代码可以通过编译，但是如果再在类CA中添加了构造函数，或者添加析构函数，就会出现错误。

由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针。

#### 其他限制

- 可以含有构造函数、析构函数

- 不能含有引用类型的成员

- 不能继承自其他类，不能作为基类

- 不能含有虚函数

- 匿名 union 在定义所在作用域可直接访问 union 成员

- 匿名 union 不能包含 protected 成员或 private 成员

- 全局匿名联合必须是静态（static）的

  ```c++
  int main() {
      UnionTest u;
      union {
          int i;
          double d;
      };
      std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10
      ::i = 20;
      std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20
      i = 30;
      std::cout << i << std::endl;    // 输出局部匿名联合的 30
      return 0;
  }
  ```

### 隐式转换

### 对象切片

### static

### const

### extern

### ifndef 

### const和constexpr的区别

#### 基本概念

`constexpr` 是 C++11 引入的，一方面是为了引入更多的编译时计算能力，另一方面也是解决 C++98 的 `const` 的双重语义问题。

`const`修饰的变量的初始化可以延迟到运行时；在修饰返回值和传入参数的时候，`const`表示只读的意思，所以有双重语义的问题。

#### 修饰变量

`const`修饰变量，有顶层和底层之分。

```c++
const int sz = get_size(); // 虽然sz无法改变，但get_size() 编译阶段无法确定值

int i = 10;
int *const p1 = &i; // 顶层const
const int *p2 = &i; // 底层const

p1 = new int(20); // 错误，顶层const指针自身无法修改
p2 = new int(30); // 正确，底层const指针可以修改
*p1 = 40; // 正确，顶层const指针指向的对象可以修改
*p2 = 40; // 错误，底层const指针指向的对象无法修改
```

`constexpr`修饰的变量在编译时必须初始化。

**`constexpr` 修饰指针，仅对指针有效，与指针所指对象无关**

```c++
constexpr int mf = 20; // 字面量20是常量表达式
constexpr int limit = mf + 1; // mf + 1是常量表达式
constexpr int sz = size(); // 只有当size是constexpr函数时，才是正确的

// j的定义必须放在函数体外
int j = 30;

// 函数体内
constexpr int *pp1 = &j; // 等价于 int constexpr *pp1 = &j;
cout << *pp1 << endl; // 30
*pp1 = 40;
cout << j << endl; // 40
pp1 = nullptr; // 错误，constexpr指针无法修改

```

#### 修饰函数

```c++
class A{
public:
  A():curSize(10) {}
  int size() const { return curSize; }  // 不能写任何数据成员
  const int size() { return curSize; }  // 函数体可以修改数据成员，但返回类型是const，也就是调用者无法修改
  constexpr int getMaxSize() { return INT_MAX; } // 不能返回非常量值

private:
  int curSize;
}
```

`constexpr`无法修饰成员函数，只能作为函数返回值类型，表明该函数返回的是一个编译期可确定的常量。。

#### 总结

`const`更多的是只读，`constexpr`才是真正的常量。

#### 参考链接

1. [C++> const和constexpr区别与联系](https://www.cnblogs.com/fortunely/p/14550145.html)
2. [C++ const 和 constexpr 的区别？](https://www.zhihu.com/question/35614219)

