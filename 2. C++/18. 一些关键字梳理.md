# 一些关键字梳理

### explicit

#### 介绍

- explicit 修饰构造函数时，可以**防止隐式转换和复制初始化**

- explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

  ```c++
  struct A{
  	A(int) { }
  	operator bool() const { return true; }
  };
  struct B{
  	explicit B(int) {}
  	explicit operator bool() const { return true; }
  };
  void doA(A a) {}
  void doB(B b) {}
  int main(){
  	A a1(1);		// OK：直接初始化
  	A a2 = 1;		// OK：复制初始化
  	A a3{ 1 };		// OK：直接列表初始化
  	A a4 = { 1 };		// OK：复制列表初始化
  	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
  	doA(1);			// OK：允许从 int 到 A 的隐式转换
  	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a6(a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
  	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化
      
  	B b1(1);		// OK：直接初始化
  	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
  	B b3{ 1 };		// OK：直接列表初始化
  	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
  	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
  	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
  	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
  	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
  	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
  	return 0;
  }
  ```

#### 参考链接

1. [C++ explicit关键字详解](https://blog.csdn.net/guoyunfei123/article/details/89003369)

### union

#### 基础

##### 定义

一种特殊的类，一个union可以有多个数据成员

```c++
union Token{
   char cval;
   int ival;
   double dval;
};
```

##### 互斥赋值

**在任意时刻，联合中只能有一个数据成员可以有值**。当给联合中某个成员赋值之后，该联合中的其它成员就变成未定义状态了。

##### 字节数

**union的字节数至少能容纳其最大的数据成员**。因为token中长度最大的变量是double类型，所以token的长度是8个字节。

##### 访问权限

默认为public，可以指定为protected和private

##### 指定成员长度

```c++
union U {
    unsigned short int aa;
    struct {
        unsigned int bb : 7;//(bit 0-6)
        unsigned int cc : 6;//(bit 7-12)
        unsigned int dd : 3;//(bit 13-15)
    };
} u;

u.aa = 0xE07F;
```

##### 类当union的成员

```c++
class CA{
     int m_a;
};
union Test{
     CA a;
     double d;
};
```

上述代码可以通过编译，但是如果再在类CA中添加了构造函数，或者添加析构函数，就会出现错误。

由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针。

#### 其他限制

- 可以含有构造函数、析构函数

- 不能含有引用类型的成员

- 不能继承自其他类，不能作为基类

- 不能含有虚函数

- 匿名 union 在定义所在作用域可直接访问 union 成员

- 匿名 union 不能包含 protected 成员或 private 成员

- 全局匿名联合必须是静态（static）的

  ```c++
  int main() {
      UnionTest u;
      union {
          int i;
          double d;
      };
      std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10
      ::i = 20;
      std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20
      i = 30;
      std::cout << i << std::endl;    // 输出局部匿名联合的 30
      return 0;
  }
  ```

