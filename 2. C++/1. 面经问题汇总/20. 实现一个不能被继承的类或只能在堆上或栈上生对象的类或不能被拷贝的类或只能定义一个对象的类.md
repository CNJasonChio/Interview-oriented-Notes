# 实现一个不能被继承的类或只能在堆上或栈上生对象的类或不能被拷贝的类或只能定义一个对象的类
## 目录 or TODO
- [ ] 1.实现一个特殊的类
- [ ] 2.不能被继承的类
- [ ] 3.只能在堆上生成对象的类
- [ ] 4.只能在栈上生成对象的类
- [ ] 5.只能定义一个对象的类
## 正文

### 1. 实现一个特殊的类

在C++中，类的对象建立分为两种，一种是静态建立，如`A a`；另一种是动态建立，如`A* ptr=new A`。 

**静态建立**一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，**直接调用类的构造函数**。 

**动态建立**类对象，是使用`new`运算符将对象建立在**堆**空间中。这个过程分为两步，**第一步**是执行`operator  new()`函数，在堆空间中搜索合适的内存并进行分配；**第二步**是调用构造函数构造对象，初始化这片内存空间。这种方法，**间接调用类的构造函数**。

### 2. 不能被继承的类

#### 2.1. final关键字

C++11中已经有了final关键字：它的作用是指定类的虚函数不能被该类的继承类重写（override），或者是指定一个类成为一个不能被继承的类。

#### 2.2. 将构造函数设置为私有

将其**构造函数设置为`private`**，当一个类试图从它那继承的时候，必然会由于试图调用构造函数而导致编译错误。

如果父类构造函数设置为`private`，父类对象也无法从外面构造。所以类中要实现有一个**静态成员函数**来构造处对象。如果声明为静态的，这个函数就属于整个类域，就可以不通过对象来调用而构造出对象。

```c++
class  A{
public:
	static  A* create() {
		return   new  A();
	}
	void  destory() {
		delete   this;
	}
private:
	A() {}
	~A() {}
};
A a = A::create();
a.destory();
```

### 3. 只能在堆上生成对象的类

只能在堆上生成对象，那就不能静态建立对象，即不能直接调用类的构造函数，只能使用`new`建立对象。将类的构造函数设置为`private`，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，`new`运算符第一步是执行`operator  new()`函数，第二步调用构造函数构造对象，但因为构造函数是`private`，所以无法调用。因此，这种方法不可以。

#### 3.1. 将析构函数设置为私有

编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。**如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。**类中必须提供一个destory函数，来进行内存空间的释放。

#### 3.2. 将析构函数设置为保护

**上述方法无法解决继承问题**。如果A作为的基类，则析构函数通常要设为`virtual`，然后在子类重写，以实现多态。因此析构函数不能设为私有。将析构函数设为`protected`可以有效解决这个问题，类外无法访问`protected`成员，子类则可以访问。 

#### 3.3. 统一用静态函数来构建和释放对象

类的使用很不方便，使用`new`建立对象，却使用`destory函数`释放对象，而不neng 使用`delete`这种使用方式比较怪异。为了统一，可以将构造函数设为`protected`，然后提供一个`public`的`static`函数来完成构造，这样不使用`new`，而是使用一个函数来构造，使用一个函数来析构。

```c++
class  A{
public:
	static  A* create() {
		return   new  A();
	}
	void  destory() {
		delete   this;
	}
protected:
	A() {}
	~A() {}
};
```

### 4. 只能在栈上生成对象的类

只能在栈上生成对象，那只能直接调用构造函数，而不能使用`new`，因此把`new`设置为`private`即可。

```c++
class  A  {  
private :  
    void * operator  new ( size_t  t){}		// 注意函数的第一个参数和返回值都是固定的 
    void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete   
public :  
    A(){}  
    ~A(){}  
}; 
```

#### 4.1. 不能被拷贝的类

拷贝意味着拷贝构造函数和赋值运算符，将拷贝构造函数和赋值运算符声明为 `protected` 的，并且不需要实现。

```c++
class T{
protected: 
	T(const T& rhs);
	T& operator = (const T& rhs);
};
```

### 5. 只能定义一个对象的类

相当于**单例模式**。将**构造函数声明为 private** 

**饿汉模式**：在类还没有实例化对象前，在类中就有一个对象，而且不能创建其他的对象。执行效率高,获取对象快，但是在类加载的时候就初始化对象，会浪费内存空间，用空间换取时间的方式

**懒汉模式**：用时间换取空间，需要的时候再创建对象，如果已经创建好了就不会再分配内存空间。它在类加载的时候不会被初始化

```c++
//饿汉单例模式
template<class T>
class SingLeton {
public:
    // 调用对象 data
    static T* getsingleton() {
        return &data;
    }
private:
    //在类还没有实例化对象前就有一个对象了
    static T data;
};

// 懒汉单例模式
template<class T>
class Singleton {
public:
    static T* GetSingleton() {
        if (data == nullptr) {
            data = new T();
        }
        return data;
    }
private:
    static T* data;
};
T* T::pt = 0;
```

volatile 保持内存的可见性：所有线程都能看到共享内存的最新状态，如果一个线程创建了 data 对象，但是被优化到寄存器，别的线程不知道，可能会继续创建对象。每次读取前必须先从主内存刷新最新的值，每次写入后必须立即同步回主内存当中。

竞态条件：从多进程间通信的角度来讲，是指两个或多个线程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。

#### 5.1. 参考链接

1. [ 如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)
2. [用C++设计一个不能被继承的类](https://www.cnblogs.com/luxiaoxun/archive/2013/06/07/3124948.html)
3. [限制一个类的对象实例,只能在”堆”上分配,或者只能在”栈”上分配](https://www.codenong.com/cs100136544/)

