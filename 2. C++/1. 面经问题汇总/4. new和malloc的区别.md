# new和malloc的区别
## 目录 or TODO
- [ ] 1.总览
- [ ] 2.类型不同
- [ ] 3.重载
- [ ] 4.申请内存的位置不同
- [ ] 5.返回类型安全
- [ ] 6.申请失败的返回值
- [ ] 7.客户处理内存分配不足
- [ ] 8.是否需要指定内存大小
- [ ] 9.是否调用构造函数
- [ ] 10.对数组的处理
- [ ] 11.new 的实现可以基于 malloc
- [ ] 12.重新分配内存
- [ ] 13.总结
## 区别

### 1. 总览

<img src="https://images.961110.xyz/images/2021/09/28/newmalloc.png" alt="new和malloc的区别" style="zoom:40%;" />

### 2. 类型不同

`malloc`和`free`是c++/c语言的**标准库函数**；而`new`和`delete`是c++的**运算符**。

### 3. 重载

`opeartor new /operator delete` 可以被重载

### 4. 申请内存的位置不同

new 从自由存储区上申请内存， malloc 从堆上申请内存。
自由存储区是 C++ 基于 new 操作符的一个抽象概念。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。
自由存储区是否能够是堆，这取决于 `operator new` 的实现细节。**自由存储区不仅可以是堆，还可以是静态存储区。**

### 5. 返回类型安全

`new` 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 **`new` 是符合类型安全性的操作符**。

malloc 内存分配成功则是返回 `void *` ，需要通过强制类型转换将 `void *` 指针转换成我们需要的类型。

### 6. 申请失败的返回值

`new` 内存分配失败时，会抛出 `bac_alloc` 异常，它**不会返回 NULL**；`malloc` 分配内存失败时返回 `NULL`

```c++
// C
int * a = new int();
if(NULL == a){...}
else{...}
// C++
try{
    int *a = new int();
}
catch (bad_alloc){...}
```

### 7. 客户处理内存分配不足

在 `operator new` 抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是**new-handler**。`new_handler` 是一个指针类型，指向了一个没有参数没有返回值的函数,，即为错误处理函数。为了指定错误处理函数，客户需要调用 `set_new_handler`，这是一个声明于标准库的函数

```c++
namespace std{
    typedef void (*new_handler)();
}

namespace std{
    new_handler set_new_handler(new_handler p ) throw();
}
```

`set_new_handler` 返回值也是个指针，指向 `set_new_handler` 被调用前正在执行（但马上就要发生替换）的那个 `new_handler` 函数。
对于 `malloc` 直接返回 `NULL`。

### 8. 是否需要指定内存大小

使用 new 操作符申请内存分配时无须指定内存块的大小，malloc 则需要显式地指出所需内存的尺寸。

```c++
A * ptr = new A;
A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A); 
```

### 9. 是否调用构造函数

new 操作符来分配对象内存时会经历三个步骤：

1. 第一步：调用 `operator new` 函数（对于数组是 `operator new[]`）分配一块足够大的，**原始**的，未命名的内存空间。
2. 第二步：编译器运行相应的**构造函数**以构造对象，并为其传入初值。
3. 第三步：对象构造完成后，返回一个指向该对象的指针。

malloc 则不会调用构造函数

### 10. 对数组的处理

C++ 提供了 `new[]` 与 `delete[]` 来专门处理数组类型

```
A * ptr = new A[10];//分配10个A对象
delete [] ptr;
int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
free (ptr);
```

### 11. new 的实现可以基于 malloc



### 12. 重新分配内存

使用 `malloc` 分配的内存后，如果在使用过程中发现内存不足，可以使用 `realloc` 函数进行内存重新分配。`realloc`先判断当前位置是否有足够的连续空间，有就原地扩大，返回原来的地址；没有就先申请，再拷贝，最后释放原内存。
`new` 没有这样直观的配套设施来扩充内存。

### 13. 总结

|         特征         |              new/delete               |             malloc/free              |
| :------------------: | :-----------------------------------: | :----------------------------------: |
|    分配内存的位置    |              自由存储区               |                  堆                  |
| 内存分配成功的返回值 |             完整类型指针              |                void*                 |
| 内存分配失败的返回值 |             默认抛出异常              |               返回NULL               |
|    分配内存的大小    |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|       处理数组       |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|   已分配内存的扩充   |            无法直观地处理             |         使用realloc简单完成          |
|     是否相互调用     | 可以，看具体的operator new/delete实现 |             不可调用new              |
|  分配内存时内存不足  | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|       函数重载       |                 允许                  |                不允许                |
|  构造函数与析构函数  |                 调用                  |                不调用                |

#### 13.1. 参考链接

1. [细说new与malloc的10点区别](https://www.cnblogs.com/qg-whz/p/5140930.html)

