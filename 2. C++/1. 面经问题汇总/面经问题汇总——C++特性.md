# 面经问题汇总——基本概念
## 目录 or TODO
- [ ] 1.C++ 内存布局
- [ ] 2.C++中堆和栈的区别
- [ ] 3.C++自由存储区以及和堆的区别
- [ ] 4.C++对象的内存布局
- [ ] 5.菱形继承
- [ ] 6.虚函数、纯虚函数、虚函数表以及它们的应用
- [ ] 7.为什么构造函数不能虚拟化
- [ ] 8.虚析构，什么时候析构函数定义为虚函数
- [ ] 9.构造函数和析构函数可否抛出异常，什么情况会引起内存泄漏
- [ ] 10.智能指针
- [ ] 11.lambda表达式
- [ ] 12.类型转换
- [ ] 13.多态是如何实现
- [ ] 14.泛型编程的实现原理
- [ ] 15.重载、重写（覆盖）、重定义（隐藏）
- [ ] 16.重载的底层实现
- [ ] 17.左值和右值
- [ ] 18.C++11新特性有哪些
- [ ] 19.深拷贝和浅拷贝
## 正文

### 1. C++ 内存布局

C++ 内存**从高到低**依次划分为：

1. 栈：存放局部变量、函数形参和返回值，函数结束时就释放。由编译器管理，函数调用时第一个进栈的是主函数的下一条指令的地址，然后是函数的形参（一般是从右往左依次入栈），然后是函数的局部变量。栈的容量不够的话会溢出，Windows下是2MB，Linux是8MB，可以通过`ulimit -s`设置；
2. 堆：由程序员申请并释放。OS中**通过链表记录空闲内存地址**，申请时遍历该链表；
3. 全局/静态存储区：存放全局变量和静态变量，其中 C 语言中初始化的和未初始化的分别存放在两个相邻的区域，C++ 中没有区分，程序结束后由系统释放；
4. 常量存储区：存放程序运行期间不能被改变的常量；
5. 代码区：存放函数体的二进制代码；

```c++
int a = 0;        //全局初始化区
char *p;        //全局未初始化区
int main() {
    int b;        //局部变量 栈区
    char s[] = "abc"; //s在栈区
    char *p1;    //栈区
    char *p2 = "123456";  //p2在栈区，123456 在常量区
    static int c = 0;        //全局（静态）初始化区
    char *p3 = (char *) malloc(10);    //p1和p3在栈区
    p1 = (char *) malloc(20);  //分配的10和20字节的区域就在堆区。
}
```

参考链接

1. [c++中内存的分类及堆和栈的区别](https://blog.csdn.net/zhuanshenweiliu/article/details/36005875)

### 2. C++中堆和栈的区别

1. 管理方式不同：栈由编译器管理，自动申请和释放；堆由程序员管理；
2. 空间大小不同：栈在Windows下是2MB，Linux下是8MB，可以通过`ulimit -s`设置；堆在32位系统下是4GB，64位系统下是128T；
3. 碎片是否产生：堆是空闲链表，频繁的申请释放会产生大量碎片；栈则不存在碎片问题；
4. 分配方式不同：堆都是动态分配的；栈有 2 种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放。
5. 分配效率：栈是机器系统提供的数据结构，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间，就有可能调用系统功能去增加程序数据段的内存空间。
6. 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

参考资料

[C++内存分配方式详解(堆、栈、自由存储区、全局/静态存储区和常量存储区)](https://blog.csdn.net/u013007900/article/details/79338653)

### 3. C++自由存储区以及和堆的区别

- 自由存储是 C++ 中通过`new`与`delete`动态分配和释放对象的**抽象概念**，而堆是 C 语言和操作系统的术语，是操作系统维护的一块动态分配内存。
- `new`所申请的内存区域在 C++ 中称为自由存储区。C++编译器默认都是用堆捞实现自由存储区。
- 可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就不位于堆上了。

参考资料

1. [自由存储区和堆](https://blog.csdn.net/nie19940803/article/details/76325082)

### 4. C++对象的内存布局

#### 4.1. 参考链接

1. [C++ 对象的内存布局（上）](https://blog.csdn.net/haoel/article/details/3081328)



### 5. 菱形继承



### 6. 虚函数、纯虚函数、虚函数表以及它们的应用

[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/16.%20%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.md)

### 7. 为什么构造函数不能虚拟化

- 如果构造函数是虚函数，那需要通过虚函数表来调用，然而**虚函数表是在构造函数中初始化的**，所以不能把构造函数设置为`virtual`

“虚”构造函数的实现如下：

```C++
class Expr {
public:
    Expr();

    Expr(const Expr &);

    virtual Expr *new_expr() { return new Expr(); }

    virtual Expr *clone() { return new Expr(*this); }
};
```

#### 7.1. 参考链接

1. [C++ 构造函数和析构函数可以是虚函数嘛？](https://blog.csdn.net/qq_28584889/article/details/88749862)

### 8. 虚析构，什么时候析构函数定义为虚函数

**C++类有继承时，析构函数必须为虚函数。**

#### 8.1. 原因

- 每个非虚析构函数只负责清理自己的成员；
- 当析构一个指向派生类成员的基类指针时，如果基类的析构函数是非虚的，那程序就不知如何处理

`delete`一个指向派生类的指针时，会调用派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果基类的析构函数非虚，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就**会造成派生类对象析构不完全**。

```C++
class ClxBase {
public:
    ClxBase() {};

    ~ClxBase() { cout << "destructor of class ClxBase!" << endl; };

    virtual void DoSomething() { cout << "Do something in ClxBase!" << endl; };
};

class ClxDerived : public ClxBase {
public:
    ClxDerived() {};

    ~ClxDerived() { cout << "destructor of class ClxDerived!" << endl; };

    void DoSomething() { cout << "Do something in class ClxDerived!" << endl; };
};

ClxBase* p2 = new ClxDerived();
p2->DoSomething(); //Do something in class ClxDerived!
delete p2;	//destructor of class ClxBase! 没有先去调用派生类的析构函数，所以释放不完全
```

#### 8.2. 参考链接

1. [为什么析构函数可以为虚函数，什么情况下需要将析构函数定义为虚函数？](https://blog.csdn.net/jiadebin890724/article/details/7951461#comments)

### 9. 构造函数和析构函数可否抛出异常，什么情况会引起内存泄漏

从语法上，构造函数和析构函数都可以抛出异常。但是从逻辑和风险控制上，**构造函数可以，析构函数不可以。**

#### 9.1. 构造函数

- 在构造函数中抛出异常是C++中通知对象构造失败的唯一方法。
- 构造函数中抛出异常，对象的析构函数将不会被执行。
- 构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，**会导致内存泄露**。可以在异常处理中进行释放，或者使用智能指针进行处理。
- 当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。

#### 9.2. 析构函数

C++标准指明析构函数不能同时也不应该抛出异常。

- 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
- 通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开）
  在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。

处理办法：

不让异常进行传播，要在析构函数内处理掉问题。

#### 9.3. 参考链接

1. [C++中构造函数和析构函数抛出异常问题](https://blog.csdn.net/u012611878/article/details/78945586)
2. [C++ 构造函数抛出异常注意事项](https://blog.csdn.net/K346K346/article/details/50144947)
3. [C++学习之构造函数中的异常处理 ](https://songlee24.github.io/2015/01/12/cpp-exception-in-constructor/)

### 10. 智能指针

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/jason_dev/2.%20C%2B%2B/8.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md)

### 11. lambda表达式

详细信息

### 12. 类型转换

详细信息

### 13. 多态是如何实现



### 14. 泛型编程的实现原理



### 15. 重载、重写（覆盖）、重定义（隐藏）

虚函数重写的两个例外：

1. 协变：基类与派生类函数返回值类型不同，即基类虚函数返回基类对象的指针或引用，派生类返回派生类对象的指针或引用
2. 析构函数的重写：基类与派生类析构函数的名字不同。如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加 `virtual` 关键字，都与基类的析构函数构成重写。虽然函数名不同，其实编译器对析构函数名做了特殊处理，编译后析构函数的名称同一处理成 destructor

<img src="http://image.961110.xyz/images/2021/07/13/ebf0fcf38165abd61e5314279936454f.png" style="zoom:67%;" />

### 16. 重载的底层实现

#### 16.1. 原理

在同一作用域内的多个函数，其函数名相同，但是参数个数不同或参数类型不同或参数顺序不同，就可以发生重载。

当函数重载和默认参数组合的时候，容易出现二义性问题

```c++
void test02(int a) { ... }
void test02(int a, int b = 100) { ... }

test02(10);//错误两个函数都能调用，产生二义性编译器不知道调用哪个  
```

底层实现依赖于**name mangling**(倾轧) 技术，来改名函数名，区分参数不同的同名函数。

在编译过程中，编译器会将C++函数按照 **规定前缀+函数名字符个数+函数名+参数列表类型首字母** 命名，例如

| 函数原型               | 函数名    |
| ---------------------- | --------- |
| int func(int a);       | _Z4funci  |
| int func(int a,int b); | _Z4funcii |

但是不同系统和编译的命名方式可能不同。

函数返回类型不能作为函数重载的条件之一，原因可能是在命名倾轧的规则中并没有对函数返回类型进行处理。

#### 16.2. 禁用命名倾轧

C++ 命名倾轧的函数是无法被 C 语言调用的。C++ 的函数必须是没有倾轧的才能调用。 使用声明`extern "C"`的函数会禁止命名倾轧，这样 C++ 的函数就可以被 C 语言调用。

#### 16.3. 参考链表

1. [重载原理分析](https://www.jianshu.com/p/f17aa6ecb3a3)

### 17. 左值和右值

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/jason_dev/2.%20C%2B%2B/12.%20%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC.md)

### 18. C++11新特性有哪些

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/17.%20C%2B%2B11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7.md)

### 19. 深拷贝和浅拷贝

[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/13.%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D.md)

