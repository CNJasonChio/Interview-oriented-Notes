# 面经问题汇总

- [ ] C++和C的区别
- [ ] C++和Java的区别
- [ ] 一些关键字
- [ ] 通过const成员函数实现非const成员函数
- [x] 指针和引用
- [ ] 内存泄漏
- [x] 内存对齐
- [ ] 多线程
- [ ] 静态和非静态成员函数
- [ ] C++异常机制
- [ ] 初始化列表
- [ ] 菱形继承
- [ ] 野指针、悬挂指针、空指针
- [ ] 结构体和联合体
- [ ] C++内存中的堆和栈

## 基本概念

### C++和C的区别

### C++和Java的区别

### 数组越界怎么检查解决

**C和C++都不检查数组索引是否越界。**

- 常规数组无法判断数组是否越界，可以通过宏定义限制数组大小；

- 可以使用容器`vector`，`vec.at()`可以进行越界检查（`std::out_of_range` 异常），`vec[i]`会退化成数组，不会进行越界判断

- 使用断言检查数组越界
- 自定义数组类

### new和malloc的区别

### 空指针NULL和nullptr的区别

#### C语言的 `NULL`

C语言中 `NULL`表示空指针，定义为`#define NULL ((void *)0)`

`void *` 指针赋值给 `int *` 和 `foo_t *` 的指针的时候，隐式转换成相应的类型。而如果换做一个 C++ 编译器来编译会出错，因为 **C++ 是强类型的**，`void *` 是不能隐式转换成其他指针类型的

#### C++的 0

通常，编译器提供的头文件会这样定义 `NULL`：

```c++
#ifdef __cplusplus ---简称：cpp c++ 文件
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```

```c++
void bar(sometype1 a, sometype2 *b);
bar(a, b);	// 可通过编译
bar(a, b);	// 可通过编译

void bar(sometype1 a, int i);	// 对bar进行重载
```

在重载`bar`的时候，会发现它调用的还是`void bar(sometype1 a, sometype2 *b)`，因为 0 是整数，除非将 0 强制转为 `sometype2 *`  》》`bar(a, static_cast<sometype2 *>(0))`

#### C++ 的 nullptr

`nullptr`可以解决C++ 中 0 的问题

#### 参考资料

1. [史上最明白的 NULL、0、nullptr 区别分析](https://www.cnblogs.com/porter/p/3611718.html)

### 类的默认成员函数有哪些

构造函数、析构函数、拷贝构造函数、赋值运算符重载函数、取地址操作符重载、`const`修饰的取地址操作符重载。

#### 构造函数

**构造函数的特性**

- 函数名与类名相同。
- 无返回值。
- 实例化对象时系统会自动调用对应的构造函数。
- 构造函数可以重载。
- 可在类内或类外定义，在类外定义的格式：`类名 + :: + 函数名`。
- 如果类定义中没有给出构造函数，则 C++ 编译器会自动生成一个缺省的构造函数。
- 无参的构造函数和带缺省值的构造函数都认为是缺省的构造函数，所以缺省的构造函数只能有一个。

#### 拷贝构造函数

缺省的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化，**默认拷贝是浅拷贝**

#### 析构函数

**析构函数的特性**

- 无参数，无返回值，所以不能重载。
- 一个类有且只有一个析构函数；
- 全局对象或者静态局部对象，则它们在 `main` 函数结束或者调用 `exit` 函数时才被析构。
- 可以使`virtual`

#### 赋值运算符重载

拷贝赋值函数在给目标对象赋值的时候，**先释放目标对象的资源**，然后再复制源对象给目标对象，所以**需要判断目标对象和源对象是否是同一个对象**

```c++
if (this != &source){...}
```

#### 取地址运算符重载和const修饰的取地址运算符重载

```c++
Date* operator&(){}
const Date* operator&()const{}
```



#### 参考资料

1. [类的默认成员函数](https://blog.csdn.net/m0_38121874/article/details/81294920)

### 一个空类占用的内存大小是多少

**类是没有大小的**，问题问的应该是类的实例的大小。

**C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小**，原因在于：

- new需要分配不同的内存地址，不能分配内存大小为0的空间
- 避免除以`sizeof(T)`时得到除以 0 错误

#### 空类大小

故使用一个字节来区分空类，**空类的大小是 1 个字节**

#### 继承于一个空类

当子类继承于一个空基类时，这个空基类不在独立，而是附属于子类，因此不会将空类的 1 个字节大小加到子类中去。

#### 空类对象作为数据成员

```c++
class Empty {};
class HoldsAnInt {
    int x;
    Empty e;
};
```

`sizeof(HoldsAnInt)` 输出为 8，因为有内存对齐的问题。

#### 参考链接

1. [空类的大小是多少？原因是什么？](https://blog.csdn.net/ZWE7616175/article/details/81084964)

### 类的大小

一个对象的大小 **大于等于** 所有的**非静态成员**大小的总和。

`sizeof(类)`得到的结果等于**各非静态数据成员总和加上编译器额外增加的字节**。后者依赖于不同的编译器实现，C++标准对此不做任何保证。

**一个类中成员函数、虚函数、静态数据成员都是不占用类的存储空间的。**

#### 指向虚函数表的指针

对于有虚函数的类，需要有一个方法为它的实体提供类型信息和虚函数入口，一般的方法是建立一个虚表（虚函数表）。在实例化时，在对象中增加一个指向虚函数的指针，许多编译器都是这样规定的。

#### 内存对齐



### 指针内存大小

- **指针类型的大小是固定的**，在 32 位系统中为 4 字节；在 64 位系统中为 8 字节；
- 对指针类型的变量进行加减操作时，与指针指向的具体数据类型有关了。`char*`指针加 1，地址+1，`int*`指针加1，地址 +4 ；

### 一些关键字

#### static

#### const

#### extern

#### ifndef 

### 通过const成员函数实现非const成员函数

`this`指针通过`static_cast`转化为常量指针，调用`const`成员函数，将其返回的结果通过`const_cast`移除常量属性。

### const对象、非const对象、const成员函数与非const成员函数的相互调用

#### const对象调用非const成员函数

**不能**。`const`修饰的对象实则修饰的是该对象的`this`指针，并且`const`修饰的成员不能进行修改，如果使用`const`对象调用非`const`成员函数，可能会将`const`对象进行修改。

#### 非const对象可以调用const成员函数

可以。

#### const成员函数调用非const成员函数

**不可以**

`const`修饰类成员函数，实际修饰该成员函数**隐含的this指针**，表明在成员函数中**不能对类的任何成员进行修改。**在用该`const`成员函数访问其他非`const`成员函数可能会修改，因此`const`成员函数不能调用非`const`成员函数。

#### 非const成员函数调用const成员函数

可以

#### 总结

感觉const就像权限管理一样，const相当于只读，非const就是读写，只读当然不能调用读写了。

#### 参考链接

1. [C++ const对象与非const对象的相互调用、const成员函数与非const成员函数的相互调用_Moua的博客-CSDN博客](https://blog.csdn.net/qq_47406941/article/details/113729810)
2. [C++类中const成员函数与非const成员函数的调用规则_qq_931027577-CSDN博客](https://blog.csdn.net/qq_44695386/article/details/106224838?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-4&spm=1001.2101.3001.4242)

### 指针和引用

#### 基本概念

**指针**  就是一个存放变量地址的变量，逻辑上是**独立**的，指针指向的地址和指向地址的内容都可以改变。

**引用**  是变量的一个别名，**不独立**，**定义时必须初始化，且之后不能变**。

#### 引用不能变的原因

从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。
指针变量在符号表上对应的地址值为指针变量的地址值
引用在符号表上对应的地址值为引用对象的地址值。
符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。

#### 区别

- 引用不能为空，指针可以为空；
- 引用只能在定义时被初始化一次，指针可变；

- 指针是一个实体，而引用仅是个别名，是否给引用分配内存，取决于编译器；
- `sizeof 引用`得到的是所指向的变量(对象)的大小，而`sizeof 指针`得到的是指针本身的大小；
- 引用没有const，指针有`const`，`const`指针不可变；
  `int& const a`表示引用本身不可变，没有意义，`const int& a`指引用所指的值不可以改变。
- 指针和引用的自增、自减运算意义不一样；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

#### 作用

##### 引用

1. 传递可变参数；

2. 传递大型对象；

3. 引用返回值。

   需要确保引用的有效性，返回的对象退出作用域被销毁，那这个引用就是无效的。

#### 参考链接

1. [C++中引用传递与指针传递区别（进一步整理） - - ITeye博客](https://www.iteye.com/blog/xinklabi-653643)
2. [详解C++指针和引用 - 简书 (jianshu.com)](https://www.jianshu.com/p/9d4f5ab84d40)

### memmove 和 memcpy的区别以及memccpy

`memcpy()` 和 `memmove()`都是 C 语言中的库函数，在头文件 `string.h` 中，作用是拷贝一定长度的内存的内容，原型分别如下：

```c++
void *memcpy(void *dst, const void *src, size_t count);
void *memmove(void *dst, const void *src, size_t count);
```

他们的作用是一样的，都是返回一个指向 `dest` 的指针。唯一的区别是，**当内存发生局部重叠的时候，`memmove` 保证拷贝的结果是正确的，`memcpy` 不保证拷贝的结果的正确。**

<img src="http://961110.xyz:7007/images/2021/07/06/memcpy6905be53712e4bb5.png" alt="memcpy内存重叠问题" style="zoom:67%;" />

`memcpy()`在情况二会发生错误。`memmove`在情况二的时候，会从后往前拷贝。

#### memmove

```c++
void* __cdecl memmove(void* dst, const void* src, size_t count)
{
	void* ret = dst;
	if (dst <= src || (char*)dst >= ((char*)src + count)) {
		// 没有重叠，则从低到高拷贝
		while (count--) {
			*(char*)dst = *(char*)src;
			dst = (char*)dst + 1;
			src = (char*)src + 1;
		}
	}
	else {
		// 有重叠，则从高到拷贝
		dst = (char*)dst + count - 1;
		src = (char*)src + count - 1;
		while (count--) {
			*(char*)dst = *(char*)src;
			dst = (char*)dst - 1;
			src = (char*)src - 1;
		}
	}

	return(ret);
}
```

#### memccpy

原型：
`extern void *memccpy(void *dest, void *src, unsigned char ch, unsigned int count);`

遇到字符 `ch` 则停止复制。

返回指向字符 `ch` 后的第一个字符的指针，如果 `src` 前 n 个字节中不存在 `ch` 则返回 NULL。

#### 参考链接

1. [MyBlog/memcpy与memmove区别和实现.md](https://github.com/SigalHu/MyBlog/blob/master/C%2B%2B/memcpy与memmove区别和实现.md)；
2. [memmove 和 memcpy的区别以及处理内存重叠问题](https://blog.csdn.net/Li_Ning_/article/details/51418400)

### 内存泄漏

#### C++内存泄漏的几种情况

##### 没有成对使用 new 和 delete

##### 没有正确地清除嵌套的对象指针

##### 释放对象数组的时候没有使用`delete[]`

##### 没有重载赋值运算符

调用默认的拷贝赋值函数，浅拷贝，导致目标对象的指针成员指向的内存泄漏；

##### 没有将基类的析构函数定义为虚函数

当基类指针指向子类对象时，如果基类的析构函数不是 `virtual`，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

##### 参考资料

1. [C++中内存泄漏的几种情况_Coding everyday...-CSDN博客](https://blog.csdn.net/lovely20085901/article/details/39050085?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base)

### 内存对齐

### 如何判断两个float相等？

**由于计算精度的原因，采用“==”运算符是不可行的**。

**除了能用 2 的指数幂乘以整数表示的浮点数能够被精确的表示外，其余的浮点数都是近似表示的。**

float 型： 占 4 字节，7 位有效数字

double 型：占 8 字节，15～16 位有效数字

#### **设置容错阈值**

```c++
if (abs(d2 - d1) < epsilon)
    cout << "Equal!" << endl;
```

不建议用一个常数值来做`epsilon`。因为随着比较数的改变，`epsilon`也应该随之改变来适应精度要求。

选择epsilon = 0.01。当数量级都在10^9以上，但是二者的差值是0.02。0.02对于差值对于两个数而言可以忽略不计，因此二者就是近似相等的。然而依据0.01做判断，二者被判定为不相等。

#### 参考链接

1. [c++ 浮点数相等判断背后的陷阱和原理 - 简书 (jianshu.com)](https://www.jianshu.com/p/b4f0dc31fd4e)
2. [深入理解C++浮点数（float、double）类型数据比较、相等操作判断](https://www.cnblogs.com/WinkJie/p/13301690.html)



### 多线程



### i++、++i都不是原子操作

`++i`和`i++`的过程：读取 i 的值，增加 i 的值，回写 i 的新值，每一步都是原子操作，但是组合起来就不是了。

```c++
std::vector vct{ 1, 2, 3 };
auto itr = vct.begin();

_Myiter operator++(int){
    // itr++，这里需要定义临时变量
    _Myiter _Tmp = *this;
    ++*this;
    return (_Tmp);
}

_Myiter& operator++(){
	// ++itr
    ++*(_Mybase *)this;
    return (*this);
}
```

在迭代中，使用 ++ 运算符，只是为了让迭代器内置的指针 + 1 而已，并不需要指针移动之前迭代器的副本，所以使用前置 ++ 会比后置 ++ 更加节省内存。换言之，复杂的循环中使用前置 ++ 会提高效率。

#### `volatile`不能保证原子性

本质上是禁止编译器将该变量优化到寄存器中，处理器每次使用这个变量值的时候都会从存储器中读取（可能命中高速缓存）。这个关键字只作用在编译器层面，处理器并不感知`volatile`的存在与作用。无法保障连续 3 步读改写的原子性。所以使用lock才是唯一正确的选择。而且，使用了lock前缀之后，也就无需再使用volatile关键字了。

#### 参考链接

1. [++i 是原子操作吗？](https://cloud.tencent.com/developer/article/1774787)
2. [【C/C++】深入理解原子操作 & volatile i为什么不能保证i++的原子性](http://www.cxyzjd.com/article/qq_43401808/86540962)

### 实现一个不能被继承的类或只能在堆上或栈上生对象的类或不能被拷贝的类或只能定义一个对象的类

### 给定一块内存 如何在这块内存上调用类的构造函数

### 已知一个结构体一个成员变量的地址 如何知道这个结构体的地址（不知道成员变量的顺序的情况下） 

```
strcut A S;
&S.c-&((struct A*)0)->c;
```



### 静态/非静态成员函数



### 菱形继承



### 结构体和联合体的区别



### C++ 程序编译到运行经历了什么

源代码–>预处理–>编译–>优化–>汇编–>链接–>目标程序

详细内容

### C++ 内存中的堆栈，堆和栈具体是什么，区别



### C++ 野指针、悬挂指针、空指针



#### 参考链接

1. [C/C++ 野指针、指针悬挂_bl520025的专栏-CSDN博客_c++指针悬挂](https://blog.csdn.net/bl520025/article/details/8967648)

### 初始化列表

使用初始化列表的优点

- 如果类存在继承关系，派生类可以直接在其初始化列表里调用基类的特定构造函数以向它传递参数，因为不能在初始化对象时访问基类的数据成员。
- 类的**非静态 const 数据成员和引用成员**只能在初始化列表里初始化，因为它们只存在初始化语义，而不存在赋值语义。
- 使用初始化列表的方式效率更高。

### C++异常机制

#### 参考链接

1. [C++ 异常机制分析](https://www.cnblogs.com/QG-whz/p/5136883.html)

### C++自由存储区

### C++对象的内存布局

#### 参考链接

1. [C++ 对象的内存布局（上）_陈皓专栏　【空谷幽兰，心如皓月】-CSDN博客_c++ 内存布局](https://blog.csdn.net/haoel/article/details/3081328)

## C++特性

### 虚函数、纯虚函数、虚函数表、应用



### 为什么构造函数不能虚拟化



### 虚析构，什么时候析构函数定义为虚函数



### 构造函数和析构函数，析构函数可否抛出异常，什么情况会引起内存泄漏

### 智能指针



### lambda表达式



### 类型转换



### 多态是如何实现



### 重载的底层实现



### 左值和右值





### C++11新特性有哪些

initializer_list

[c++initializer_list详解_rotation博客-CSDN博客_c++ initializer_list](https://blog.csdn.net/fengxinlinux/article/details/72614874)

### 深拷贝和浅拷贝

Done

## STL

### 常用容器，vector和list区别，resize和reserve区别，erase底层



### STL有哪些组件



### map和unorder_map有哪些区别,map为什么是log n的查询和修改时间



### map中红黑树最长路径和最短路径的差值



### 哈希表如何实现、哈希冲突



### 模板函数



### vector内存管理



### STL中Set中存储一个类对象 如何设计？



### 双向queue的实现原理



## 参考链接

1. [那些不能遗忘的知识点回顾——C/C++系列（笔试面试高频题）](https://www.cnblogs.com/webary/p/4754522.html)
2. [C++内存问题，看这篇就够了 - SegmentFault 思否](https://segmentfault.com/a/1190000039348996?utm_source=tag-newest)

