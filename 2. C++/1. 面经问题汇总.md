# 面经问题汇总

- [ ] C++和C的区别
- [ ] C++和Java的区别
- [ ] 一些关键字
- [ ] 通过const成员函数实现非const成员函数
- [x] 指针和引用
- [ ] 内存泄漏
- [ ] 内存对齐
- [ ] 多线程
- [ ] 静态和非静态成员函数
- [ ] C++异常机制
- [ ] 初始化列表
- [ ] 菱形继承
- [ ] 野指针、悬挂指针、空指针
- [ ] 结构体和联合体
- [ ] C++内存中的堆和栈

## 基本概念

### C++和C的区别

函数默认值

**C89 标准的 C 语言不支持函数默认值，C++ 支持函数默认值，且需要遵循从右向左赋初始值。**



C++对C的增强，表现在以下六个方面：

- 增强了类型检查机制
- 增加了面向对象的机制
- 增加了泛型编程的机制（template）
- 增加了异常处理
- 增加了重载的机制
- 增加了标准模板库（STL）

#### 增强了类型检查机制

很多时候需要一种能够实际表示多种类型的数据类型。传统上 C 使用 **void* 指针**指向不同对象，使用时强制转换回原始类型或兼容类型。这样做的缺陷是绕过了编译器的类型检查。C++ 通过**使用基类指针或引用**来代替 void* 的使用。

#### 增加了面向对象的机制

封装、继承、多态

#### 增加了泛型编程的机制（template）



#### 增加了异常处理

C语言不提供对错误处理的直接支持，通过检查返回值的方式决定程序的处理。

C++定义了一系列标准的异常，

| 异常                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| std::exception       | 该异常是所有标准C++异常的父类。                              |
| std::bad_alloc       | 该异常可以通过new抛出。                                      |
| std::bad_cast        | 该异常可以通过dynamic_cast抛出。                             |
| std:bad_exception    | 这在处理C++程序中无法预期的异常时非常有用。                  |
| std::bad_typeid      | 该异常可以通过typeid抛出。                                   |
| std:logic_error      | 理论上可以通过读取代码来检测到的异常。                       |
| std::domain error    | 当使用了一个无效的数学域时,会抛出该异常。                    |
| std:invalid_argument | 当使用了无效的参数时,会抛出该异常。                          |
| std:length_errors    | 当创建了太长的  std::string时,会抛出该异常。                 |
| std::out_of_range    | 该异常可以通过方法抛出,例如std::vector和  std:bitst>::operator[](). |
| std::runtime_error   | 理论上不可以通过读取代码来检测到的异常。                     |
| std::overflow_error  | 当发生数学上溢时,会抛出该异常。                              |
| std::range _error    | 当尝试存储超出范围的值时,会抛出该异常。                      |
| std::underflow error | 当发生数学下溢时,会抛出该异常。                              |

#### 增加了重载的机制

**函数重载和运算符重载**



#### 增加了标准模板库（STL）



#### 参考链接

1. [C 与 C++ 的区别 - 简书 (jianshu.com)](https://www.jianshu.com/p/2522b07219ae)
2. [C语言和C++的区别_Eyoru的博客-CSDN博客_c++和c语言的区别](https://blog.csdn.net/czc1997/article/details/81254971?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-5.base)

### C++和Java的区别

### 数组越界怎么检查解决

**C和C++都不检查数组索引是否越界。**

- 常规数组无法判断数组是否越界，可以通过宏定义限制数组大小；

- 可以使用容器`vector`，`vec.at()`可以进行越界检查（`std::out_of_range` 异常），`vec[i]`会退化成数组，不会进行越界判断

- 使用断言检查数组越界
- 自定义数组类

### new和malloc的区别

#### 类型不同

`malloc`和`free`是c++/c语言的**标准库函数**；而`new`和`delete`是c++的**运算符**。

#### 重载

`opeartor new /operator delete` 可以被重载

#### 申请内存的位置不同

new 从自由存储区上申请内存， malloc 从堆上申请内存。
自由存储区是 C++ 基于 new 操作符的一个抽象概念。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。
自由存储区是否能够是堆，这取决于 `operator new` 的实现细节。**自由存储区不仅可以是堆，还可以是静态存储区。**

#### 返回类型安全

`new` 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 **`new` 是符合类型安全性的操作符**。

malloc 内存分配成功则是返回 `void *` ，需要通过强制类型转换将 `void *` 指针转换成我们需要的类型。

#### 申请失败的返回值

`new` 内存分配失败时，会抛出 `bac_alloc` 异常，它**不会返回 NULL**；`malloc` 分配内存失败时返回 `NULL`

```c++
// C
int * a = new int();
if(NULL == a){...}
else{...}
// C++
try{
    int *a = new int();
}
catch (bad_alloc){...}
```

#### 客户处理内存分配不足

在 `operator new` 抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是**new-handler**。`new_handler` 是一个指针类型，指向了一个没有参数没有返回值的函数,，即为错误处理函数。为了指定错误处理函数，客户需要调用 `set_new_handler`，这是一个声明于标准库的函数

```c++
namespace std{
    typedef void (*new_handler)();
}

namespace std{
    new_handler set_new_handler(new_handler p ) throw();
}
```

`set_new_handler` 返回值也是个指针，指向 `set_new_handler` 被调用前正在执行（但马上就要发生替换）的那个 `new_handler` 函数。
对于 `malloc` 直接返回 `NULL`。

#### 是否需要指定内存大小

使用 new 操作符申请内存分配时无须指定内存块的大小，malloc 则需要显式地指出所需内存的尺寸。

```c++
A * ptr = new A;
A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A); 
```

#### 是否调用构造函数

new 操作符来分配对象内存时会经历三个步骤：

1. 第一步：调用 `operator new` 函数（对于数组是 `operator new[]`）分配一块足够大的，**原始**的，未命名的内存空间。
2. 第二步：编译器运行相应的**构造函数**以构造对象，并为其传入初值。
3. 第三步：对象构造完成后，返回一个指向该对象的指针。

malloc 则不会调用构造函数

#### 对数组的处理

C++ 提供了 `new[]` 与 `delete[]` 来专门处理数组类型

```
A * ptr = new A[10];//分配10个A对象
delete [] ptr;
int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
free (ptr);
```

#### new 的实现可以基于 malloc



#### 重新分配内存

使用 `malloc` 分配的内存后，如果在使用过程中发现内存不足，可以使用 `realloc` 函数进行内存重新分配。`realloc`先判断当前位置是否有足够的连续空间，有就原地扩大，返回原来的地址；没有就先申请，再拷贝，最后释放原内存。
`new` 没有这样直观的配套设施来扩充内存。

#### 总结

|         特征         |              new/delete               |             malloc/free              |
| :------------------: | :-----------------------------------: | :----------------------------------: |
|    分配内存的位置    |              自由存储区               |                  堆                  |
| 内存分配成功的返回值 |             完整类型指针              |                void*                 |
| 内存分配失败的返回值 |             默认抛出异常              |               返回NULL               |
|    分配内存的大小    |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|       处理数组       |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|   已分配内存的扩充   |            无法直观地处理             |         使用realloc简单完成          |
|     是否相互调用     | 可以，看具体的operator new/delete实现 |             不可调用new              |
|  分配内存时内存不足  | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|       函数重载       |                 允许                  |                不允许                |
|  构造函数与析构函数  |                 调用                  |                不调用                |

#### 参考链接

1. [细说new与malloc的10点区别](https://www.cnblogs.com/qg-whz/p/5140930.html)



### 空指针NULL和nullptr的区别

#### C语言的 `NULL`

C语言中 `NULL`表示空指针，定义为`#define NULL ((void *)0)`

`void *` 指针赋值给 `int *` 和 `foo_t *` 的指针的时候，隐式转换成相应的类型。而如果换做一个 C++ 编译器来编译会出错，因为 **C++ 是强类型的**，`void *` 是不能隐式转换成其他指针类型的

#### C++的 0

通常，编译器提供的头文件会这样定义 `NULL`：

```c++
#ifdef __cplusplus ---简称：cpp c++ 文件
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```

```c++
void bar(sometype1 a, sometype2 *b);
bar(a, b);	// 可通过编译
bar(a, b);	// 可通过编译

void bar(sometype1 a, int i);	// 对bar进行重载
```

在重载`bar`的时候，会发现它调用的还是`void bar(sometype1 a, sometype2 *b)`，因为 0 是整数，除非将 0 强制转为 `sometype2 *`  》》`bar(a, static_cast<sometype2 *>(0))`

#### C++ 的 nullptr

`nullptr`可以解决C++ 中 0 的问题

#### 参考资料

1. [史上最明白的 NULL、0、nullptr 区别分析](https://www.cnblogs.com/porter/p/3611718.html)

### 类的默认成员函数有哪些

构造函数、析构函数、拷贝构造函数、赋值运算符重载函数、取地址操作符重载、`const`修饰的取地址操作符重载。

#### 构造函数

**构造函数的特性**

- 函数名与类名相同。
- 无返回值。
- 实例化对象时系统会自动调用对应的构造函数。
- 构造函数可以重载。
- 可在类内或类外定义，在类外定义的格式：`类名 + :: + 函数名`。
- 如果类定义中没有给出构造函数，则 C++ 编译器会自动生成一个缺省的构造函数。
- 无参的构造函数和带缺省值的构造函数都认为是缺省的构造函数，所以缺省的构造函数只能有一个。

#### 拷贝构造函数

缺省的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化，**默认拷贝是浅拷贝**

#### 析构函数

**析构函数的特性**

- 无参数，无返回值，所以不能重载。
- 一个类有且只有一个析构函数；
- 全局对象或者静态局部对象，则它们在 `main` 函数结束或者调用 `exit` 函数时才被析构。
- 可以使`virtual`

#### 赋值运算符重载

拷贝赋值函数在给目标对象赋值的时候，**先释放目标对象的资源**，然后再复制源对象给目标对象，所以**需要判断目标对象和源对象是否是同一个对象**

```c++
if (this != &source){...}
```

#### 取地址运算符重载和const修饰的取地址运算符重载

```c++
Date* operator&(){}
const Date* operator&()const{}
```



#### 参考资料

1. [类的默认成员函数](https://blog.csdn.net/m0_38121874/article/details/81294920)

### 一个空类占用的内存大小是多少

**类是没有大小的**，问题问的应该是类的实例的大小。

**C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小**，原因在于：

- new需要分配不同的内存地址，不能分配内存大小为0的空间
- 避免除以`sizeof(T)`时得到除以 0 错误

#### 空类大小

故使用一个字节来区分空类，**空类的大小是 1 个字节**

#### 继承于一个空类

当子类继承于一个空基类时，这个空基类不在独立，而是附属于子类，因此不会将空类的 1 个字节大小加到子类中去。

#### 空类对象作为数据成员

```c++
class Empty {};
class HoldsAnInt {
    int x;
    Empty e;
};
```

`sizeof(HoldsAnInt)` 输出为 8，因为有内存对齐的问题。

#### 参考链接

1. [空类的大小是多少？原因是什么？](https://blog.csdn.net/ZWE7616175/article/details/81084964)

### 类的大小

一个对象的大小 **大于等于** 所有的**非静态成员**大小的总和。

`sizeof(类)`得到的结果等于**各非静态数据成员总和加上编译器额外增加的字节**。后者依赖于不同的编译器实现，C++标准对此不做任何保证。

**一个类中成员函数、虚函数、静态数据成员都是不占用类的存储空间的。**

#### 指向虚函数表的指针

对于有虚函数的类，需要有一个方法为它的实体提供类型信息和虚函数入口，一般的方法是建立一个虚表（虚函数表）。在实例化时，在对象中增加一个指向虚函数的指针，许多编译器都是这样规定的。

#### 内存对齐



### 指针内存大小

- **指针类型的大小是固定的**，在 32 位系统中为 4 字节；在 64 位系统中为 8 字节；
- 对指针类型的变量进行加减操作时，与指针指向的具体数据类型有关了。`char*`指针加 1，地址+1，`int*`指针加1，地址 +4 ；

### 一些关键字

#### static

#### const

#### extern

#### ifndef 

### 通过const成员函数实现非const成员函数

`this`指针通过`static_cast`转化为常量指针，调用`const`成员函数，将其返回的结果通过`const_cast`移除常量属性。

### const对象、非const对象、const成员函数与非const成员函数的相互调用

#### const对象调用非const成员函数

**不能**。`const`修饰的对象实则修饰的是该对象的`this`指针，并且`const`修饰的成员不能进行修改，如果使用`const`对象调用非`const`成员函数，可能会将`const`对象进行修改。

#### 非const对象可以调用const成员函数

可以。

#### const成员函数调用非const成员函数

**不可以**

`const`修饰类成员函数，实际修饰该成员函数**隐含的this指针**，表明在成员函数中**不能对类的任何成员进行修改。**在用该`const`成员函数访问其他非`const`成员函数可能会修改，因此`const`成员函数不能调用非`const`成员函数。

#### 非const成员函数调用const成员函数

可以

#### 总结

感觉const就像权限管理一样，const相当于只读，非const就是读写，只读当然不能调用读写了。

#### 参考链接

1. [C++ const对象与非const对象的相互调用、const成员函数与非const成员函数的相互调用_Moua的博客-CSDN博客](https://blog.csdn.net/qq_47406941/article/details/113729810)
2. [C++类中const成员函数与非const成员函数的调用规则_qq_931027577-CSDN博客](https://blog.csdn.net/qq_44695386/article/details/106224838?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-4&spm=1001.2101.3001.4242)

### 指针和引用

#### 基本概念

**指针**  就是一个存放变量地址的变量，逻辑上是**独立**的，指针指向的地址和指向地址的内容都可以改变。

**引用**  是变量的一个别名，**不独立**，**定义时必须初始化，且之后不能变**。

#### 引用不能变的原因

从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。
指针变量在符号表上对应的地址值为指针变量的地址值
引用在符号表上对应的地址值为引用对象的地址值。
符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。

#### 区别

- 引用不能为空，指针可以为空；
- 引用只能在定义时被初始化一次，指针可变；

- 指针是一个实体，而引用仅是个别名，是否给引用分配内存，取决于编译器；
- `sizeof 引用`得到的是所指向的变量(对象)的大小，而`sizeof 指针`得到的是指针本身的大小；
- 引用没有const，指针有`const`，`const`指针不可变；
  `int& const a`表示引用本身不可变，没有意义，`const int& a`指引用所指的值不可以改变。
- 指针和引用的自增、自减运算意义不一样；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

#### 作用

##### 引用

1. 传递可变参数；

2. 传递大型对象；

3. 引用返回值。

   需要确保引用的有效性，返回的对象退出作用域被销毁，那这个引用就是无效的。

#### 参考链接

1. [C++中引用传递与指针传递区别（进一步整理） - - ITeye博客](https://www.iteye.com/blog/xinklabi-653643)
2. [详解C++指针和引用 - 简书 (jianshu.com)](https://www.jianshu.com/p/9d4f5ab84d40)

### memmove 和 memcpy的区别以及memccpy

`memcpy()` 和 `memmove()`都是 C 语言中的库函数，在头文件 `string.h` 中，作用是拷贝一定长度的内存的内容，原型分别如下：

```c++
void *memcpy(void *dst, const void *src, size_t count);
void *memmove(void *dst, const void *src, size_t count);
```

他们的作用是一样的，都是返回一个指向 `dest` 的指针。唯一的区别是，**当内存发生局部重叠的时候，`memmove` 保证拷贝的结果是正确的，`memcpy` 不保证拷贝的结果的正确。**

<img src="http://961110.xyz:7007/images/2021/07/06/memcpy6905be53712e4bb5.png" alt="memcpy内存重叠问题" style="zoom:67%;" />

`memcpy()`在情况二会发生错误。`memmove`在情况二的时候，会从后往前拷贝。

#### memmove

```c++
void* __cdecl memmove(void* dst, const void* src, size_t count)
{
	void* ret = dst;
	if (dst <= src || (char*)dst >= ((char*)src + count)) {
		// 没有重叠，则从低到高拷贝
		while (count--) {
			*(char*)dst = *(char*)src;
			dst = (char*)dst + 1;
			src = (char*)src + 1;
		}
	}
	else {
		// 有重叠，则从高到拷贝
		dst = (char*)dst + count - 1;
		src = (char*)src + count - 1;
		while (count--) {
			*(char*)dst = *(char*)src;
			dst = (char*)dst - 1;
			src = (char*)src - 1;
		}
	}

	return(ret);
}
```

#### memccpy

原型：
`extern void *memccpy(void *dest, void *src, unsigned char ch, unsigned int count);`

遇到字符 `ch` 则停止复制。

返回指向字符 `ch` 后的第一个字符的指针，如果 `src` 前 n 个字节中不存在 `ch` 则返回 NULL。

#### 参考链接

1. [MyBlog/memcpy与memmove区别和实现.md](https://github.com/SigalHu/MyBlog/blob/master/C%2B%2B/memcpy与memmove区别和实现.md)；
2. [memmove 和 memcpy的区别以及处理内存重叠问题](https://blog.csdn.net/Li_Ning_/article/details/51418400)

### 内存泄漏

#### C++内存泄漏的几种情况

##### 没有成对使用 new 和 delete

##### 没有正确地清除嵌套的对象指针

##### 释放对象数组的时候没有使用`delete[]`

##### 没有重载赋值运算符

调用默认的拷贝赋值函数，浅拷贝，导致目标对象的指针成员指向的内存泄漏；

##### 没有将基类的析构函数定义为虚函数

当基类指针指向子类对象时，如果基类的析构函数不是 `virtual`，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

##### 参考资料

1. [C++中内存泄漏的几种情况_Coding everyday...-CSDN博客](https://blog.csdn.net/lovely20085901/article/details/39050085?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base)

### 内存对齐

### 如何判断两个float相等？

**由于计算精度的原因，采用“==”运算符是不可行的**。

**除了能用 2 的指数幂乘以整数表示的浮点数能够被精确的表示外，其余的浮点数都是近似表示的。**

float 型： 占 4 字节，7 位有效数字

double 型：占 8 字节，15～16 位有效数字

#### **设置容错阈值**

```c++
if (abs(d2 - d1) < epsilon)
    cout << "Equal!" << endl;
```

不建议用一个常数值来做`epsilon`。因为随着比较数的改变，`epsilon`也应该随之改变来适应精度要求。

选择epsilon = 0.01。当数量级都在10^9以上，但是二者的差值是0.02。0.02对于差值对于两个数而言可以忽略不计，因此二者就是近似相等的。然而依据0.01做判断，二者被判定为不相等。

#### 参考链接

1. [c++ 浮点数相等判断背后的陷阱和原理 - 简书 (jianshu.com)](https://www.jianshu.com/p/b4f0dc31fd4e)
2. [深入理解C++浮点数（float、double）类型数据比较、相等操作判断](https://www.cnblogs.com/WinkJie/p/13301690.html)



### 多线程



### i++、++i都不是原子操作

`++i`和`i++`的过程：读取 i 的值，增加 i 的值，回写 i 的新值，每一步都是原子操作，但是组合起来就不是了。

```c++
std::vector vct{ 1, 2, 3 };
auto itr = vct.begin();

_Myiter operator++(int){
    // itr++，这里需要定义临时变量
    _Myiter _Tmp = *this;
    ++*this;
    return (_Tmp);
}

_Myiter& operator++(){
	// ++itr
    ++*(_Mybase *)this;
    return (*this);
}
```

在迭代中，使用 ++ 运算符，只是为了让迭代器内置的指针 + 1 而已，并不需要指针移动之前迭代器的副本，所以使用前置 ++ 会比后置 ++ 更加节省内存。换言之，复杂的循环中使用前置 ++ 会提高效率。

#### `volatile`不能保证原子性

本质上是禁止编译器将该变量优化到寄存器中，处理器每次使用这个变量值的时候都会从存储器中读取（可能命中高速缓存）。这个关键字只作用在编译器层面，处理器并不感知`volatile`的存在与作用。无法保障连续 3 步读改写的原子性。所以使用lock才是唯一正确的选择。而且，使用了lock前缀之后，也就无需再使用volatile关键字了。

#### 参考链接

1. [++i 是原子操作吗？](https://cloud.tencent.com/developer/article/1774787)
2. [【C/C++】深入理解原子操作 & volatile i为什么不能保证i++的原子性](http://www.cxyzjd.com/article/qq_43401808/86540962)

### 如何实现一个特殊的类

在C++中，类的对象建立分为两种，一种是静态建立，如`A a`；另一种是动态建立，如`A* ptr=new A`。 

**静态建立**一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，**直接调用类的构造函数**。 

**动态建立**类对象，是使用`new`运算符将对象建立在**堆**空间中。这个过程分为两步，**第一步**是执行`operator  new()`函数，在堆空间中搜索合适的内存并进行分配；**第二步**是调用构造函数构造对象，初始化这片内存空间。这种方法，**间接调用类的构造函数**。

#### 不能被继承的类

##### final关键字

C++11中已经有了final关键字：它的作用是指定类的虚函数不能被该类的继承类重写（override），或者是指定一个类成为一个不能被继承的类。

##### 将构造函数设置为私有

将其**构造函数设置为`private`**，当一个类试图从它那继承的时候，必然会由于试图调用构造函数而导致编译错误。

如果父类构造函数设置为`private`，父类对象也无法从外面构造。所以类中要实现有一个**静态成员函数**来构造处对象。如果声明为静态的，这个函数就属于整个类域，就可以不通过对象来调用而构造出对象。

```c++
class  A{
public:
	static  A* create() {
		return   new  A();
	}
	void  destory() {
		delete   this;
	}
private:
	A() {}
	~A() {}
};
A a = A::create();
a.destory();
```

#### 只能在堆上生成对象的类

只能在堆上生成对象，那就不能静态建立对象，即不能直接调用类的构造函数，只能使用`new`建立对象。将类的构造函数设置为`private`，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，`new`运算符第一步是执行`operator  new()`函数，第二步调用构造函数构造对象，但因为构造函数是`private`，所以无法调用。因此，这种方法不可以。

##### 将析构函数设置为私有

编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。**如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。**类中必须提供一个destory函数，来进行内存空间的释放。

##### 将析构函数设置为保护

**上述方法无法解决继承问题**。如果A作为的基类，则析构函数通常要设为`virtual`，然后在子类重写，以实现多态。因此析构函数不能设为私有。将析构函数设为`protected`可以有效解决这个问题，类外无法访问`protected`成员，子类则可以访问。 

##### 统一用静态函数来构建和释放对象

类的使用很不方便，使用`new`建立对象，却使用`destory函数`释放对象，而不neng 使用`delete`这种使用方式比较怪异。为了统一，可以将构造函数设为`protected`，然后提供一个`public`的`static`函数来完成构造，这样不使用`new`，而是使用一个函数来构造，使用一个函数来析构。

```c++
class  A{
public:
	static  A* create() {
		return   new  A();
	}
	void  destory() {
		delete   this;
	}
protected:
	A() {}
	~A() {}
};
```

#### 只能在栈上生成对象的类

只能在栈上生成对象，那只能直接调用构造函数，而不能使用`new`，因此把`new`设置为`private`即可。

```c++
class  A  {  
private :  
    void * operator  new ( size_t  t){}		// 注意函数的第一个参数和返回值都是固定的 
    void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete   
public :  
    A(){}  
    ~A(){}  
}; 
```

#### 不能被拷贝的类

拷贝意味着拷贝构造函数和赋值运算符，将拷贝构造函数和赋值运算符声明为 `protected` 的，并且不需要实现。

```c++
class T{
protected: 
	T(const T& rhs);
	T& operator = (const T& rhs);
};
```

#### 只能定义一个对象的类

相当于**单例模式**。将**构造函数声明为 private** 

**饿汉模式**：在类还没有实例化对象前，在类中就有一个对象，而且不能创建其他的对象。执行效率高,获取对象快，但是在类加载的时候就初始化对象，会浪费内存空间，用空间换取时间的方式

**懒汉模式**：用时间换取空间，需要的时候再创建对象，如果已经创建好了就不会再分配内存空间。它在类加载的时候不会被初始化

```c++
//饿汉单例模式
template<class T>
class SingLeton {
public:
    // 调用对象 data
    static T* getsingleton() {
        return &data;
    }
private:
    //在类还没有实例化对象前就有一个对象了
    static T data;
};

// 懒汉单例模式
template<class T>
class Singleton {
public:
    static T* GetSingleton() {
        if (data == nullptr) {
            data = new T();
        }
        return data;
    }
private:
    static T* data;
};
T* T::pt = 0;
```

volatile 保持内存的可见性：所有线程都能看到共享内存的最新状态，如果一个线程创建了 data 对象，但是被优化到寄存器，别的线程不知道，可能会继续创建对象。每次读取前必须先从主内存刷新最新的值，每次写入后必须立即同步回主内存当中。

竞态条件：从多进程间通信的角度来讲，是指两个或多个线程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。

#### 参考链接

1. [ 如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)
2. [用C++设计一个不能被继承的类](https://www.cnblogs.com/luxiaoxun/archive/2013/06/07/3124948.html)
3. [限制一个类的对象实例,只能在”堆”上分配,或者只能在”栈”上分配](https://www.codenong.com/cs100136544/)

### 给定一块内存 如何在这块内存上调用类的构造函数

### 已知一个结构体一个成员变量的地址 如何知道这个结构体的地址（不知道成员变量的顺序的情况下） 

```
strcut A S;
&S.c-&((struct A*)0)->c;
```



### 静态/非静态成员函数



### 菱形继承



### 结构体和联合体的区别



### C++ 程序编译到运行经历了什么

源代码–>预处理–>编译–>优化–>汇编–>链接–>目标程序

#### 预处理

处理预编处理宏定义、条件编译指令、条件包含指令、特殊符号。综合来说实际上就是一个替换的动作,处理带 # 符号的命令和一些特殊符号.

`gcc -E hello.cpp hw.i`

#### 编译

词法分析、语法分析。在确定所有的指令都符合语法规则后，将其翻译成目标代码。
在编译的过程中，所有的变量都是虚拟地址，在汇编文件中有一个表，存储了虚拟地址对应的变量名称.
`g++ -S hello.i -o hello.s`

#### 优化

不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。

优化一部分是对中间代码的优化。这种优化不依赖于具体的计算机。另一种优化则主要针对目标代码的生成而进行的。

对于前一种优化，主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。

后一种类型的优化同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数。另外，如何根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行一些调整使目标代码比较短，执行的效率比较高，也是一个重要的研究课题。

经过优化得到的汇编代码必须经过汇编程序的汇编转换成相应的机器指令，方可能被机器执行。

#### 汇编

经历汇编过程编译转换成机器码,，最终形成与源程序等效的机器码。目标文件由段组成。通常一个目标文件至少有两个段  代码段 和 数据段。代码段包含了可读可执行的程序的指令。数据段保存各种全局变量和静态的数据。一般数据段可读可写可执行

`gcc -c hello.c -o hello.o` 这里的 hello.o 就是最后的机器码. 作为一个静态库的话可以说已经完成了, 不需要后面的流程。

#### 链接

目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如：

- 某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；
- 在程序中可能调用了某个库文件中的函数。

链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：

**静态链接**

静态链接将链接库的代码复制到可执行程序中，使得可执行程序体积变大
**动态链接**

动态链接指的是需要链接的代码放到一个共享对象中，共享对象映射到进程虚地址空间，链接程序记录可执行程序将来需要用的代码信息，根据这些信息迅速定位相应的代码片段。

#### 参考链接

1. [c/c++ 从编译到执行_zt_xiaozhi-CSDN博客](https://blog.csdn.net/u010009169/article/details/72231774)

### C++ 内存中的堆栈，堆和栈具体是什么，区别



### C++ 野指针、悬挂指针、空指针



#### 参考链接

1. [C/C++ 野指针、指针悬挂_bl520025的专栏-CSDN博客_c++指针悬挂](https://blog.csdn.net/bl520025/article/details/8967648)

### 初始化列表

使用初始化列表的优点

- 如果类存在继承关系，派生类可以直接在其初始化列表里调用基类的特定构造函数以向它传递参数，因为不能在初始化对象时访问基类的数据成员。
- 类的**非静态 const 数据成员和引用成员**只能在初始化列表里初始化，因为它们只存在初始化语义，而不存在赋值语义。
- 使用初始化列表的方式效率更高。

### C++异常机制

#### 参考链接

1. [C++ 异常机制分析](https://www.cnblogs.com/QG-whz/p/5136883.html)

### C++自由存储区

## C++特性

### 虚函数、纯虚函数、虚函数表、应用



### 为什么构造函数不能虚拟化



### 虚析构，什么时候析构函数定义为虚函数



### 构造函数和析构函数，析构函数可否抛出异常，什么情况会引起内存泄漏

### 智能指针



### lambda表达式



### 类型转换



### 多态是如何实现



### 重载的底层实现



### 左值和右值





### C++11新特性有哪些

initializer_list

[c++initializer_list详解_rotation博客-CSDN博客_c++ initializer_list](https://blog.csdn.net/fengxinlinux/article/details/72614874)

### 深拷贝和浅拷贝

Done

## STL

### 常用容器，vector和list区别，resize和reserve区别，erase底层



### STL有哪些组件



### map和unorder_map有哪些区别,map为什么是log n的查询和修改时间



### map中红黑树最长路径和最短路径的差值



### 哈希表如何实现、哈希冲突



### 模板函数



### vector内存管理



### STL中Set中存储一个类对象 如何设计？



### 双向queue的实现原理



## 参考链接

1. [那些不能遗忘的知识点回顾——C/C++系列（笔试面试高频题）](https://www.cnblogs.com/webary/p/4754522.html)
2. [C++内存问题，看这篇就够了 - SegmentFault 思否](https://segmentfault.com/a/1190000039348996?utm_source=tag-newest)

