# 面经问题汇总

## 目录 or TODO

### 1. 基本概念

- [x] 1. C++和C的区别
- [x] 2. C++和Java的区别
- [x] 3. 数组越界怎么检查解决
- [x] 4. new和malloc的区别
- [x] 5. 空指针NULL和nullptr的区别
- [x] 6. 类的默认成员函数有哪些
- [x] 7. 一个空类占用的内存大小是多少
- [x] 8. 类的大小
- [x] 9. 指针内存大小
- [ ] 10. 一些关键字
- [x] 11. 通过const成员函数实现非const成员函数
- [x] 12. const对象、非const对象、const成员函数与非const成员函数的相互调用
- [x] 13. 指针和引用
- [x] 14. memmove 和 memcpy的区别以及memccpy
- [x] 15. 内存泄漏
- [x] 16. 内存对齐
- [x] 17. 如何判断两个float相等？
- [ ] 18. 多线程
- [x] 19. i++、++i都不是原子操作
- [x] 20. 实现一个不能被继承的类或只能在堆上或栈上生对象的类或不能被拷贝的类或只能定义一个对象的类
- [ ] 21. 给定一块内存 如何在这块内存上调用类的构造函数
- [ ] 22. 已知一个结构体一个成员变量的地址 如何知道这个结构体的地址（不知道成员变量的顺序的情况下） 
- [ ] 23. 静态/非静态成员函数
- [ ] 24. 结构体和联合体的区别
- [x] 25. C++ 程序编译到运行经历了什么
- [x] 26. C++ 野指针、悬挂指针、空指针
- [ ] 27. 初始化列表
- [ ] 28. C++异常机制

### 2. C++特性

- [x] 1. C++ 内存布局
- [ ] 2. C++中堆和栈的区别
- [x] 3. C++自由存储区以及和堆的区别
- [ ] 4. C++对象的内存布局
- [ ] 5. 菱形继承
- [ ] 6. 虚函数、纯虚函数、虚函数表以及它们的应用
- [x] 7. 为什么构造函数不能虚拟化
- [x] 8. 虚析构，什么时候析构函数定义为虚函数
- [x] 9. 构造函数和析构函数可否抛出异常，什么情况会引起内存泄漏
- [ ] 10. 智能指针
- [ ] 11. lambda表达式
- [ ] 12. 类型转换
- [ ] 13. 多态是如何实现
- [ ] 14. 重载、重写（覆盖）、重定义（隐藏）
- [x] 15. 重载的底层实现
- [ ] 16. 左值和右值
- [ ] 17. C++11新特性有哪些
- [x] 18. 深拷贝和浅拷贝

### 3. STL

- [ ] 1. STL有哪些组件
- [ ] 2. 常用容器
- [ ] 3. map和unorder_map有哪些区别,map为什么是log n的查询和修改时间
- [ ] 4. map中红黑树最长路径和最短路径的差值
- [x] 5. 哈希表如何实现、哈希冲突
- [ ] 6. 模板函数
- [ ] 7. vector和list区别
- [x] 8. resize和reserve的区别
- [x] 9. vector中erase和remove
- [x] 10. vector内存管理
- [x] 11. vector 迭代器失效
- [ ] 12. STL中Set中存储一个类对象 如何设计？
- [ ] 13. 双向queue的实现原理


## 基本概念

### 1. C++和C的区别

[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/1.%20C%2B%2B%E5%92%8CC%E4%BB%A5%E5%8F%8AJava%E7%9A%84%E5%8C%BA%E5%88%AB.md)

### 2. C++和Java的区别

[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/1.%20C%2B%2B%E5%92%8CC%E4%BB%A5%E5%8F%8AJava%E7%9A%84%E5%8C%BA%E5%88%AB.md)

### 3. 数组越界怎么检查解决

**C和C++都不检查数组索引是否越界。**

- 常规数组无法判断数组是否越界，可以通过宏定义限制数组大小；

- 可以使用容器`vector`，`vec.at()`可以进行越界检查（`std::out_of_range` 异常），`vec[i]`会退化成数组，不会进行越界判断

- 使用断言检查数组越界
- 自定义数组类

### 4. new和malloc的区别
[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/4.%20new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB.md)

### 5. 空指针NULL和nullptr的区别

#### 5.1. C语言的 `NULL`

C语言中 `NULL`表示空指针，定义为`#define NULL ((void *)0)`

`void *` 指针赋值给 `int *` 和 `foo_t *` 的指针的时候，隐式转换成相应的类型。而如果换做一个 C++ 编译器来编译会出错，因为 **C++ 是强类型的**，`void *` 是不能隐式转换成其他指针类型的

#### 5.2. C++的 0

通常，编译器提供的头文件会这样定义 `NULL`：

```c++
#ifdef __cplusplus ---简称：cpp c++ 文件
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```

```c++
void bar(sometype1 a, sometype2 *b);
bar(a, b);	// 可通过编译
bar(a, b);	// 可通过编译

void bar(sometype1 a, int i);	// 对bar进行重载
```

在重载`bar`的时候，会发现它调用的还是`void bar(sometype1 a, sometype2 *b)`，因为 0 是整数，除非将 0 强制转为 `sometype2 *`  》》`bar(a, static_cast<sometype2 *>(0))`

#### 5.3. C++ 的 nullptr

`nullptr`可以解决C++ 中 0 的问题

#### 5.4. 参考资料

1. [史上最明白的 NULL、0、nullptr 区别分析](https://www.cnblogs.com/porter/p/3611718.html)

### 6. 类的默认成员函数有哪些

构造函数、析构函数、拷贝构造函数、赋值运算符重载函数、取地址操作符重载、`const`修饰的取地址操作符重载。

#### 6.1. 构造函数

**构造函数的特性**

- 函数名与类名相同。
- 无返回值。
- 实例化对象时系统会自动调用对应的构造函数。
- 构造函数可以重载。
- 可在类内或类外定义，在类外定义的格式：`类名 + :: + 函数名`。
- 如果类定义中没有给出构造函数，则 C++ 编译器会自动生成一个缺省的构造函数。
- 无参的构造函数和带缺省值的构造函数都认为是缺省的构造函数，所以缺省的构造函数只能有一个。

#### 6.2. 拷贝构造函数

缺省的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化，**默认拷贝是浅拷贝**

#### 6.3. 析构函数

**析构函数的特性**

- 无参数，无返回值，所以不能重载。
- 一个类有且只有一个析构函数；
- 全局对象或者静态局部对象，则它们在 `main` 函数结束或者调用 `exit` 函数时才被析构。
- 可以使`virtual`

#### 6.4. 赋值运算符重载

拷贝赋值函数在给目标对象赋值的时候，**先释放目标对象的资源**，然后再复制源对象给目标对象，所以**需要判断目标对象和源对象是否是同一个对象**

```c++
if (this != &source){...}
```

#### 6.5. 取地址运算符重载和const修饰的取地址运算符重载

```c++
Date* operator&(){}
const Date* operator&()const{}
```



#### 6.6. 参考资料

1. [类的默认成员函数](https://blog.csdn.net/m0_38121874/article/details/81294920)

### 7. 一个空类占用的内存大小是多少

**类是没有大小的**，问题问的应该是类的实例的大小。

**C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小**，原因在于：

- new需要分配不同的内存地址，不能分配内存大小为0的空间
- 避免除以`sizeof(T)`时得到除以 0 错误

#### 7.1. 空类大小

故使用一个字节来区分空类，**空类的大小是 1 个字节**

#### 7.2. 继承于一个空类

当子类继承于一个空基类时，这个空基类不在独立，而是附属于子类，因此不会将空类的 1 个字节大小加到子类中去。

#### 7.3. 空类对象作为数据成员

```c++
class Empty {};
class HoldsAnInt {
    int x;
    Empty e;
};
```

`sizeof(HoldsAnInt)` 输出为 8，因为有内存对齐的问题。

#### 7.4. 参考链接

1. [空类的大小是多少？原因是什么？](https://blog.csdn.net/ZWE7616175/article/details/81084964)

### 8. 类的大小

一个对象的大小 **大于等于** 所有的**非静态成员**大小的总和。

`sizeof(类)`得到的结果等于**各非静态数据成员总和加上编译器额外增加的字节**。后者依赖于不同的编译器实现，C++标准对此不做任何保证。

**一个类中成员函数、虚函数、静态数据成员都是不占用类的存储空间的。**

#### 8.1. 指向虚函数表的指针

对于有虚函数的类，需要有一个方法为它的实体提供类型信息和虚函数入口，一般的方法是建立一个虚表（虚函数表）。在实例化时，在对象中增加一个指向虚函数的指针，许多编译器都是这样规定的。

#### 8.2. 内存对齐
[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/16.%20%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.md)

### 9. 指针内存大小

- **指针类型的大小是固定的**，在 32 位系统中为 4 字节；在 64 位系统中为 8 字节；
- 对指针类型的变量进行加减操作时，与指针指向的具体数据类型有关了。`char*`指针加 1，地址+1，`int*`指针加1，地址 +4 ；

### 10. 一些关键字

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/18.%20%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97%E6%A2%B3%E7%90%86.md)

### 11. 通过const成员函数实现非const成员函数

`this`指针通过`static_cast`转化为常量指针，调用`const`成员函数，将其返回的结果通过`const_cast`移除常量属性。

### 12. const对象、非const对象、const成员函数与非const成员函数的相互调用

#### 12.1. const对象调用非const成员函数

**不能**。`const`修饰的对象实则修饰的是该对象的`this`指针，并且`const`修饰的成员不能进行修改，如果使用`const`对象调用非`const`成员函数，可能会将`const`对象进行修改。

#### 12.2. 非const对象可以调用const成员函数

可以。

#### 12.3. const成员函数调用非const成员函数

**不可以**

`const`修饰类成员函数，实际修饰该成员函数**隐含的this指针**，表明在成员函数中**不能对类的任何成员进行修改。**在用该`const`成员函数访问其他非`const`成员函数可能会修改，因此`const`成员函数不能调用非`const`成员函数。

#### 12.4. 非const成员函数调用const成员函数

可以

#### 12.5. 总结

感觉const就像权限管理一样，const相当于只读，非const就是读写，只读当然不能调用读写了。

#### 12.6. 参考链接

1. [C++ const对象与非const对象的相互调用、const成员函数与非const成员函数的相互调用_Moua的博客-CSDN博客](https://blog.csdn.net/qq_47406941/article/details/113729810)
2. [C++类中const成员函数与非const成员函数的调用规则_qq_931027577-CSDN博客](https://blog.csdn.net/qq_44695386/article/details/106224838?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-4&spm=1001.2101.3001.4242)

### 13. 指针和引用

#### 13.1. 基本概念

**指针**  就是一个存放变量地址的变量，逻辑上是**独立**的，指针指向的地址和指向地址的内容都可以改变。

**引用**  是变量的一个别名，**不独立**，**定义时必须初始化，且之后不能变**。

#### 13.2. 引用不能变的原因

从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。
指针变量在符号表上对应的地址值为指针变量的地址值
引用在符号表上对应的地址值为引用对象的地址值。
符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。

#### 13.3. 区别

- 引用不能为空，指针可以为空；
- 引用只能在定义时被初始化一次，指针可变；

- 指针是一个实体，而引用仅是个别名，是否给引用分配内存，取决于编译器；
- `sizeof 引用`得到的是所指向的变量(对象)的大小，而`sizeof 指针`得到的是指针本身的大小；
- 引用没有const，指针有`const`，`const`指针不可变；
  `int& const a`表示引用本身不可变，没有意义，`const int& a`指引用所指的值不可以改变。
- 指针和引用的自增、自减运算意义不一样；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

#### 13.4. 作用

##### 13.4.1. 引用

1. 传递可变参数；

2. 传递大型对象；

3. 引用返回值。

   需要确保引用的有效性，返回的对象退出作用域被销毁，那这个引用就是无效的。

#### 13.5. 参考链接

1. [C++中引用传递与指针传递区别（进一步整理） - - ITeye博客](https://www.iteye.com/blog/xinklabi-653643)
2. [详解C++指针和引用 - 简书 (jianshu.com)](https://www.jianshu.com/p/9d4f5ab84d40)

### 14. memmove 和 memcpy的区别以及memccpy

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/memmove%20%E5%92%8C%20memcpy%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8Amemccpy.md)

### 15. 内存泄漏

#### 15.1. C++内存泄漏的几种情况

1. 没有成对使用 new 和 delete
2. 没有正确地清除嵌套的对象指针
3. 没有正确释放对象数组
   释放对象数组的时候要使用`delete[]`
4. 没有重载赋值运算符
   调用默认的拷贝赋值函数，浅拷贝，导致目标对象的指针成员指向的内存泄漏；
5. 没有将基类的析构函数定义为虚函数
   当基类指针指向子类对象时，如果基类的析构函数不是 `virtual`，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

##### 15.1.1. 参考资料

1. [C++中内存泄漏的几种情况_Coding everyday...-CSDN博客](https://blog.csdn.net/lovely20085901/article/details/39050085?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base)

### 16. 内存对齐

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/16.%20%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.md)

### 17. 如何判断两个float相等？

**由于计算精度的原因，采用“==”运算符是不可行的**。

**除了能用 2 的指数幂乘以整数表示的浮点数能够被精确的表示外，其余的浮点数都是近似表示的。**

float 型： 占 4 字节，7 位有效数字

double 型：占 8 字节，15～16 位有效数字

#### 17.1. **设置容错阈值**

```c++
if (abs(d2 - d1) < epsilon)
    cout << "Equal!" << endl;
```

不建议用一个常数值来做`epsilon`。因为随着比较数的改变，`epsilon`也应该随之改变来适应精度要求。

选择epsilon = 0.01。当数量级都在10^9以上，但是二者的差值是0.02。0.02对于差值对于两个数而言可以忽略不计，因此二者就是近似相等的。然而依据0.01做判断，二者被判定为不相等。

#### 17.2. 参考链接

1. [c++ 浮点数相等判断背后的陷阱和原理 - 简书 (jianshu.com)](https://www.jianshu.com/p/b4f0dc31fd4e)
2. [深入理解C++浮点数（float、double）类型数据比较、相等操作判断](https://www.cnblogs.com/WinkJie/p/13301690.html)



### 18. 多线程



### 19. i++、++i都不是原子操作

`++i`和`i++`的过程：读取 i 的值，增加 i 的值，回写 i 的新值，每一步都是原子操作，但是组合起来就不是了。

```c++
std::vector vct{1, 2, 3};
auto itr = vct.begin();

_Myiter operator++(int) {
    // itr++，这里需要定义临时变量
    _Myiter _Tmp = *this;
    ++*this;
    return (_Tmp);
}

_Myiter &operator++() {
    // ++itr
    ++*(_Mybase * )
    this;
    return (*this);
}
```

在迭代中，使用 ++ 运算符，只是为了让迭代器内置的指针 + 1 而已，并不需要指针移动之前迭代器的副本，所以使用前置 ++ 会比后置 ++ 更加节省内存。换言之，复杂的循环中使用前置 ++ 会提高效率。

#### 19.1. `volatile`不能保证原子性

本质上是禁止编译器将该变量优化到寄存器中，处理器每次使用这个变量值的时候都会从存储器中读取（可能命中高速缓存）。这个关键字只作用在编译器层面，处理器并不感知`volatile`的存在与作用。无法保障连续 3 步读改写的原子性。所以使用lock才是唯一正确的选择。而且，使用了lock前缀之后，也就无需再使用volatile关键字了。

#### 19.2. 参考链接

1. [++i 是原子操作吗？](https://cloud.tencent.com/developer/article/1774787)
2. [【C/C++】深入理解原子操作 & volatile i为什么不能保证i++的原子性](http://www.cxyzjd.com/article/qq_43401808/86540962)

### 20. 实现一个不能被继承的类或只能在堆上或栈上生对象的类或不能被拷贝的类或只能定义一个对象的类
[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/20.%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%E6%88%96%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E6%A0%88%E4%B8%8A%E7%94%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E6%88%96%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%B1%BB%E6%88%96%E5%8F%AA%E8%83%BD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB.md)

### 21. 给定一块内存 如何在这块内存上调用类的构造函数



### 22. 已知一个结构体一个成员变量的地址 如何知道这个结构体的地址（不知道成员变量的顺序的情况下） 

```
strcut A S;
&S.c-&((struct A*)0)->c;
```

### 23. 静态/非静态成员函数



### 24. 结构体和联合体的区别



### 25. C++ 程序编译到运行经历了什么

源代码–>预处理–>编译–>优化–>汇编–>链接–>目标程序

[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/26.%20C%2B%2B%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E5%88%B0%E8%BF%90%E8%A1%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88.md)

### 26. C++ 野指针、悬挂指针、空指针

#### 26.1. 野指针（悬挂指针）

指针既不为空，也没有指向一个已知的对象。指向一块没有分配给用户的指针。

常见成因：

1. 指针未初始化；
2. 指针指向的对象被释放；
3. 指向函数中的局部变量；

#### 26.2. 空指针

C 空指针：`NULL`；C++ 空指针：`nullptr`，在C++中`NULL`被定义成 `0`，在重载的时候可能会出现冲突。

#### 26.3. 参考链接

1. [C/C++ 野指针、指针悬挂_bl520025的专栏-CSDN博客_c++指针悬挂](https://blog.csdn.net/bl520025/article/details/8967648)

### 27. 初始化列表

使用初始化列表的优点

- 如果类存在继承关系，派生类可以直接在其初始化列表里调用基类的特定构造函数以向它传递参数，因为不能在初始化对象时访问基类的数据成员。
- 类的**非静态 const 数据成员和引用成员**只能在初始化列表里初始化，因为它们只存在初始化语义，而不存在赋值语义。
- 使用初始化列表的方式效率更高。

### 28. C++异常机制

#### 28.1. 参考链接

1. [C++ 异常机制分析](https://www.cnblogs.com/QG-whz/p/5136883.html)

## C++特性

### 1. C++ 内存布局

C++ 内存**从高到低**依次划分为：

1. 栈：存放局部变量、函数形参和返回值，函数结束时就释放。由编译器管理，函数调用时第一个进栈的是主函数的下一条指令的地址，然后是函数的形参（一般是从右往左依次入栈），然后是函数的局部变量。栈的容量不够的话会溢出，Windows下是2MB，Linux是8MB，可以通过`ulimit -s`设置；
2. 堆：由程序员申请并释放。OS中**通过链表记录空闲内存地址**，申请时遍历该链表；
3. 全局/静态存储区：存放全局变量和静态变量，其中 C 语言中初始化的和未初始化的分别存放在两个相邻的区域，C++ 中没有区分，程序结束后由系统释放；
4. 常量存储区：存放程序运行期间不能被改变的常量；
5. 代码区：存放函数体的二进制代码；

```c++
int a = 0;        //全局初始化区
char *p;        //全局未初始化区
int main() {
    int b;        //局部变量 栈区
    char s[] = "abc"; //s在栈区
    char *p1;    //栈区
    char *p2 = "123456";  //p2在栈区，123456 在常量区
    static int c = 0;        //全局（静态）初始化区
    char *p3 = (char *) malloc(10);    //p1和p3在栈区
    p1 = (char *) malloc(20);  //分配的10和20字节的区域就在堆区。
}
```

参考链接

1. [c++中内存的分类及堆和栈的区别](https://blog.csdn.net/zhuanshenweiliu/article/details/36005875)

### 2. C++中堆和栈的区别

1. 管理方式不同：栈由编译器管理，自动申请和释放；堆由程序员管理；
2. 空间大小不同：栈在Windows下是2MB，Linux下是8MB，可以通过`ulimit -s`设置；堆在32位系统下是4GB，64位系统下是128T；
3. 碎片是否产生：堆是空闲链表，频繁的申请释放会产生大量碎片；栈则不存在碎片问题；
4. 分配方式不同：堆都是动态分配的；栈有 2 种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放。
5. 分配效率：栈是机器系统提供的数据结构，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间，就有可能调用系统功能去增加程序数据段的内存空间。
6. 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

参考资料

[C++内存分配方式详解(堆、栈、自由存储区、全局/静态存储区和常量存储区)](https://blog.csdn.net/u013007900/article/details/79338653)

### 3. C++自由存储区以及和堆的区别

- 自由存储是 C++ 中通过`new`与`delete`动态分配和释放对象的**抽象概念**，而堆是 C 语言和操作系统的术语，是操作系统维护的一块动态分配内存。
- `new`所申请的内存区域在 C++ 中称为自由存储区。C++编译器默认都是用堆捞实现自由存储区。
- 可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就不位于堆上了。

参考资料

1. [自由存储区和堆](https://blog.csdn.net/nie19940803/article/details/76325082)

### 4. C++对象的内存布局

#### 4.1. 参考链接

1. [C++ 对象的内存布局（上）](https://blog.csdn.net/haoel/article/details/3081328)



### 5. 菱形继承



### 6. 虚函数、纯虚函数、虚函数表以及它们的应用

[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/16.%20%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.md)

### 7. 为什么构造函数不能虚拟化

- 如果构造函数是虚函数，那需要通过虚函数表来调用，然而**虚函数表是在构造函数中初始化的**，所以不能把构造函数设置为`virtual`

“虚”构造函数的实现如下：

```C++
class Expr {
public:
    Expr();

    Expr(const Expr &);

    virtual Expr *new_expr() { return new Expr(); }

    virtual Expr *clone() { return new Expr(*this); }
};
```

#### 7.1. 参考链接

1. [C++ 构造函数和析构函数可以是虚函数嘛？](https://blog.csdn.net/qq_28584889/article/details/88749862)

### 8. 虚析构，什么时候析构函数定义为虚函数

**C++类有继承时，析构函数必须为虚函数。**

#### 8.1. 原因

- 每个非虚析构函数只负责清理自己的成员；
- 当析构一个指向派生类成员的基类指针时，如果基类的析构函数是非虚的，那程序就不知如何处理

`delete`一个指向派生类的指针时，会调用派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果基类的析构函数非虚，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就**会造成派生类对象析构不完全**。

```C++
class ClxBase {
public:
    ClxBase() {};

    ~ClxBase() { cout << "destructor of class ClxBase!" << endl; };

    virtual void DoSomething() { cout << "Do something in ClxBase!" << endl; };
};

class ClxDerived : public ClxBase {
public:
    ClxDerived() {};

    ~ClxDerived() { cout << "destructor of class ClxDerived!" << endl; };

    void DoSomething() { cout << "Do something in class ClxDerived!" << endl; };
};

ClxBase* p2 = new ClxDerived();
p2->DoSomething(); //Do something in class ClxDerived!
delete p2;	//destructor of class ClxBase! 没有先去调用派生类的析构函数，所以释放不完全
```

#### 8.2. 参考链接

1. [为什么析构函数可以为虚函数，什么情况下需要将析构函数定义为虚函数？](https://blog.csdn.net/jiadebin890724/article/details/7951461#comments)

### 9. 构造函数和析构函数可否抛出异常，什么情况会引起内存泄漏

从语法上，构造函数和析构函数都可以抛出异常。但是从逻辑和风险控制上，**构造函数可以，析构函数不可以。**

#### 9.1. 构造函数

- 在构造函数中抛出异常是C++中通知对象构造失败的唯一方法。
- 构造函数中抛出异常，对象的析构函数将不会被执行。
- 构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，**会导致内存泄露**。可以在异常处理中进行释放，或者使用智能指针进行处理。
- 当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。

#### 9.2. 析构函数

C++标准指明析构函数不能同时也不应该抛出异常。

- 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
- 通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开）
  在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。

处理办法：

不让异常进行传播，要在析构函数内处理掉问题。

#### 9.3. 参考链接

1. [C++中构造函数和析构函数抛出异常问题](https://blog.csdn.net/u012611878/article/details/78945586)
2. [C++ 构造函数抛出异常注意事项](https://blog.csdn.net/K346K346/article/details/50144947)
3. [C++学习之构造函数中的异常处理 ](https://songlee24.github.io/2015/01/12/cpp-exception-in-constructor/)

### 10. 智能指针

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/jason_dev/2.%20C%2B%2B/8.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md)

### 11. lambda表达式

详细信息

### 12. 类型转换

详细信息

### 13. 多态是如何实现



### 14. 泛型编程的实现原理



### 15. 重载、重写（覆盖）、重定义（隐藏）

虚函数重写的两个例外：

1. 协变：基类与派生类函数返回值类型不同，即基类虚函数返回基类对象的指针或引用，派生类返回派生类对象的指针或引用
2. 析构函数的重写：基类与派生类析构函数的名字不同。如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加 `virtual` 关键字，都与基类的析构函数构成重写。虽然函数名不同，其实编译器对析构函数名做了特殊处理，编译后析构函数的名称同一处理成 destructor

<img src="http://image.961110.xyz/images/2021/07/13/ebf0fcf38165abd61e5314279936454f.png" style="zoom:67%;" />

### 16. 重载的底层实现

#### 16.1. 原理

在同一作用域内的多个函数，其函数名相同，但是参数个数不同或参数类型不同或参数顺序不同，就可以发生重载。

当函数重载和默认参数组合的时候，容易出现二义性问题

```c++
void test02(int a) { ... }
void test02(int a, int b = 100) { ... }

test02(10);//错误两个函数都能调用，产生二义性编译器不知道调用哪个  
```

底层实现依赖于**name mangling**(倾轧) 技术，来改名函数名，区分参数不同的同名函数。

在编译过程中，编译器会将C++函数按照 **规定前缀+函数名字符个数+函数名+参数列表类型首字母** 命名，例如

| 函数原型               | 函数名    |
| ---------------------- | --------- |
| int func(int a);       | _Z4funci  |
| int func(int a,int b); | _Z4funcii |

但是不同系统和编译的命名方式可能不同。

函数返回类型不能作为函数重载的条件之一，原因可能是在命名倾轧的规则中并没有对函数返回类型进行处理。

#### 16.2. 禁用命名倾轧

C++ 命名倾轧的函数是无法被 C 语言调用的。C++ 的函数必须是没有倾轧的才能调用。 使用声明`extern "C"`的函数会禁止命名倾轧，这样 C++ 的函数就可以被 C 语言调用。

#### 16.3. 参考链表

1. [重载原理分析](https://www.jianshu.com/p/f17aa6ecb3a3)

### 17. 左值和右值

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/jason_dev/2.%20C%2B%2B/12.%20%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC.md)

### 18. C++11新特性有哪些

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/17.%20C%2B%2B11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7.md)

### 19. 深拷贝和浅拷贝

[详细内容](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/13.%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D.md)

## STL

### 1. STL有哪些组件

<img src="https://images.961110.xyz/images/2021/09/27/STL.png" alt="STL六大组件" style="zoom: 33%;" />

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6.md)

### 2. 常用容器

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6/7.%20STL%E5%AE%B9%E5%99%A8.md)

### 3. map和unorder_map有哪些区别,map为什么是log n的查询和修改时间

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6/7.%20STL%E5%AE%B9%E5%99%A8.md)

### 4. map中红黑树最长路径和最短路径的差值

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/master/2.%20C%2B%2B/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6/7.%20STL%E5%AE%B9%E5%99%A8.md)

### 5. 哈希表如何实现、哈希冲突

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/jason_dev/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E3%80%81%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.md)

### 6. 模板函数

详细信息

### 7. vector和list区别



### 8. resize和reserve的区别

#### 8.1. resize和reserve区别

`reserve`增加了`vector`的`capacity`，但是它的`size`没有改变；`resize`改变了`vector`的`capacity`同时也增加了它的`size`，因为其在`resize`的时候新建了对象。

### 9. vector中erase和remove

#### 9.1. erase

`erase`删除容器中的一个或者一段元素。被删除元素之后的所有元素都向前移动，因此传入的迭代器指向没变，但是所指的元素已经发生了变化。其实`vector`还维持着一个`last`指针，开始的时候`=end`，随着删除，`last`前移，最终`vector`的`size`是`last-begin`，或者我们可以认为`end`值改变了，但最初传入的`end`没有变。

```c++
vector<int>::iterator itr = v.begin();
while (itr != v.end()) {
    if (*v == 1)
        v.erase(itr);
    itr++;//这里删除后迭代器会更新出错
}

// 正确写法
vector<int>::iterator itr = v.begin();
while (itr != v.end()) {
    if (*v == 1)
        v.erase(itr);
    else
        itr++;
}
```

#### 9.2. remove

将等于`value`的元素放到`vector`的尾部，但并不减少`vector`的`size`，返回新的`end()`值（非`val`部分的`end`）

#### 9.3. 二者结合使用

可以删除值为 x 的元素、

```c++
vec.erase(remove(vec.begin(), vec.end(), x), vec.end());
```

#### 9.4. 参考链接

1. [vector的remove和erase函数的区别](https://blog.csdn.net/xzymmd/article/details/83652726)

### 10. vector内存管理

[详细信息](https://github.com/CNJasonChio/Interview-oriented-Notes/blob/jason_dev/2.%20C%2B%2B/1.%20%E9%9D%A2%E7%BB%8F%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/vector%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md)

### 11. vector 迭代器失效

1. 详细作返回的迭代器肯定失效。
2. 当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时begin和end操作返回的迭代器都会失效。
3. 当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。

#### 11.1. 参考链接

1. [实战c++中的vector系列--可怕的迭代器失效之二（删除vector中元素）](https://dabaojian.blog.csdn.net/article/details/50334503)

### 12. STL中Set中存储一个类对象 如何设计？



### 13. 双向queue的实现原理



## 参考链接

1. [那些不能遗忘的知识点回顾——C/C++系列（笔试面试高频题）](https://www.cnblogs.com/webary/p/4754522.html)
2. [C++内存问题，看这篇就够了 - SegmentFault 思否](https://segmentfault.com/a/1190000039348996?utm_source=tag-newest)
3. [C/C++面经汇总](https://blog.nowcoder.net/n/4123469b8a54472980ca0e0ac5e6c230)

