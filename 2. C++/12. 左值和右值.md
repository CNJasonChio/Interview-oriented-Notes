# 左值和右值

## 目录 or TODO

## 正文

### 左值和右值

#### 概念

**左值**指的就存储在内存中、**可以取地址**的数据。通俗的理解就是所有有名字的变量或者对象都是左值。

**右值**指的是可以提供数据值（**不可取地址**）的数据，是匿名的。



在判断左值还是右值的时候，不能通过其在等号两边的位置来判断。

#### 右值

C++ 11中，右值分为两类：

1. 纯右值：**非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等**；
2. 将亡值：与右值引用相关的表达式，比如 `T&&`类型函数的返回值、`std:move()`的返回值等

```c++
int val = 520;
int a1;
int &&a2 = a1; 
```

其中`val`就是左值，520是字面量，所以是右值。

**用左值给右值引用初始化是不合法的。**

### 右值引用

因为右值是匿名的，所以只能通过引用的方式找到它。

**无论声明左值引用还是右值引用都必须立即进行初始化**，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。

```c++
class Test {
public:
    Test() {
        cout << "construct: my name is jerry" << endl;
    }
    Test(const Test &a) {
        cout << "copy construct: my name is tom" << endl;
    }
};
Test getObj() {
    return Test();
}

Test &t = getObj();		// 右值不能给普通的左值引用赋值
Test &&t = getObj();	// 返回的是一个将亡值，所以可以给右值引用赋值
const Test &t = getObj();
```

**常量左值引用是一个万能引用类型**，它可以接受左值、右值、常量左值和常量右值。

### 性能优化

```c++
// 会先进行构造，然后返回的时候调用拷贝构造深拷贝
Test getObj(){
    Test t;
    return t;
}

int main(){
    Test t = getObj();
    cout << "t.m_num: " << *t.m_num << endl;
    return 0;
};
```

可以利用右值引用，进行浅拷贝，避免对临时对象的深拷贝。

```c++
class Test {
public:
    Test() : m_num(new int(100)) {
        cout << "construct: my name is jerry" << endl;
    }

    Test(const Test &a) : m_num(new int(*a.m_num)) {
        cout << "copy construct: my name is tom" << endl;
    }

    // 添加移动构造函数
    Test(Test &&a) : m_num(a.m_num) {
        a.m_num = nullptr;
        cout << "move construct: my name is sunny" << endl;
    }

    ~Test() {
        delete m_num;
        cout << "destruct Test class ..." << endl;
    }

    int *m_num;
};

Test getObj() {
    Test t;
    return t;
}

int main() {
    Test t = getObj();
    cout << "t.m_num: " << *t.m_num << endl;
    return 0;
};
```

> 通过移动构造，将临时对象中的堆内存地址的所有权转移给了对象t，避免了深拷贝。
>
> 对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。
>

### &&的特性

#### 自动推导

```c++
int main() {
    int x = 520, y = 1314;
    auto &&v1 = x;
    auto &&v2 = 250;
    decltype(x) &&v3 = y;   // error
    return 0;
};
```

` auto &&v1 = x;`因为 x 是左值，所以推导会自动根据引用折叠的机制将 v1 推导成 int &

`auto &&v2 = 250;`因为 250 是右值，所以自动推导成 int 的右值引用

`decltype(x) &&v3 = y;`decltype(x)实际上是int，所以用y(左值)给int &&一个右值引用赋值是错误的。

> 通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型
>
> 通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&& 或者 auto&& 得到的是一个左值引用类型
>

```c++
int &&a1 = 5;		// 右值引用
auto &&bb = a1;		// 左值引用
auto &&bb1 = 5;		// 右值引用

int a2 = 5;
int &a3 = a2;		// 左值引用
auto &&cc = a3;		// 左值引用
auto &&cc1 = a2;	// 左值引用

const int &s1 = 100;	// 常量左值引用
const int &&s2 = 100;	// 常量右值引用
auto &&dd = s1;		// 常量左值引用
auto &&ee = s2;		// 常量左值引用

const auto &&x = 5;	// 常量右值引用
```

### 参考资料

1. [右值引用](https://subingwen.cn/cpp/rvalue-reference/#3-amp-amp-的特性)

