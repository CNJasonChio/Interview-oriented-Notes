# 9. Top K 问题
## 目录 or TODO
- [x] 1.常见问题
- [x] 2.解题方法
- [x] 3.总结
- [x] 4.LeetCode题目
- [x] 5.参考链接
## 正文

### 1. 常见问题

1. 有 10000000 个记录，这些查询串的重复度比较高，如果除去重复后，不超过 3000000 个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请统计最热门的 10 个查询串，要求使用的内存不能超过 1GB。
2. 有 10 个文件，每个文件 1GB，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。按照 query 的频度排序。
3. 有一个 1GB 大小的文件，里面的每一行是一个词，词的大小不超过 16 个字节，内存限制大小是 1MB。返回频数最高的 100 个词。
4. 提取某日访问网站次数最多的那个 IP。
5. 10 亿个整数找出重复次数最多的 100 个整数。
6. 搜索的输入信息是一个字符串，统计 300 万条输入信息中最热门的前 10 条，每次输入的一个字符串为不超过 255B，内存使用只有 1GB。
7. 有 1000 万个身份证号以及他们对应的数据，身份证号可能重复，找出出现次数最多的身份证号。

### 2. 解题方法

题目：有 1 亿个浮点数，如果找出期中最大的 10000 个

#### 2.1. 排序

最容易想到的方法，但是当数据量大，且内存受限的时候，该方法不可用。而且把所有的数据都做了排序，因此做了很多无谓工作。

1 亿个数，每个数 4 个字节，快速排序所需要的内存就达到了 400MB，时间复杂度是  O(n*log n)，空间复杂度是  O(log n)  

#### 2.2. 局部淘汰法

用一个容器保存前 10000 个数，将剩余的数字一一与容器中最小的数比较：

- 如果后续的数都比该最小数小，则找到了前 10000 个最大的数；
- 如果后续的数有比该最小数大的数，那就删掉该最小数，把新数放到容器中。

时间复杂度为 O(n+m^2)，其中 m 为容器的大小，即 10000 。

#### 2.3. 分治法

将 1 亿个数据分成 100 份，每份 100 万个数据，找到每份数据中最大的 10000 个，最后在剩下的 
100 *10000 个数据里面找出最大的 10000 个。

在 100 万个数据中查找最大的 10000 个数，可以采用快速排序的思想：

将数据分为 2 堆，如果大的那堆个数 N 大于 10000 个，继续对大堆快速排序一次分成 2 堆，如果大堆个数 N 小于 10000 个，就在小的那堆里面快速排序一次，找第 10000 - n 大的数字；递归以上过程，就可以找到第 10000 大的数。

参考上面的找出第 1w 大数字，就可以类似的方法找到前 10000 大数字了。此种方法需要每次的内存空间为 10^6*4=4MB，一共需要 101 次这样的比较。

#### 2.4. Hash 法

如果这 1 亿个数里面有很多重复的数，先通过 Hash 法，把这 1 亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的 10000 个数。

同样可以用 Hash 的方法把数划分成 N 份，然后采用分治法或者最小堆的方法查找最大的 10000 个数。

#### 2.5. 最小堆

首先读入前 10000 个数来创建大小为 10000 的最小堆，建堆的时间复杂度为 O（mlog m）（m 为数组的大小即为 10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至 1 亿个数全部遍历完为止。堆中剩下的就是 1 亿个数中最大的 10000 个数。

该算法的时间复杂度为 O（nmlog m），空间复杂度是 10000。

### 3. 总结

实际运行中需要根据运行场景进行方法的选择

1. 单机+单核+大内存：快速排序的思想
2. 单机+多核+大内存：划分成多份数据，每一份交给一个线程
3. 单机+单核+小内存：多次划分数据，然后逐个处理
4. 多机+小内存：划分数据，将数据分发
5. Map-Reduce：同样是分治法的思想

### 4. LeetCode题目

1. [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

### 5. 参考链接

1. [海量数据处理 - 10亿个数中找出最大的10000个数（top K问题）](https://blog.csdn.net/iteye_6926/article/details/82646307?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-9.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-9.control)

